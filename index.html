<!doctype html>
<html lang="pt">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
  <title>Warehouse — Operations & Control (Firebase)</title>
  <style>:root{
    --bg:#f6f7fb;
    --surface:#ffffff;
    --surface2:#fbfbfe;
    --stroke:rgba(20,24,33,.12);
    --text:#101624;
    --muted:#5b677a;
    --accent:#1f8a70;   /* verde/teal */
    --ok:#178f63;
    --danger:#d64545;
    --warn:#b88300;
    --radius:16px;
  }
  *{box-sizing:border-box;font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial,sans-serif}
  body{margin:0;background:linear-gradient(180deg,var(--bg),#ffffff);color:var(--text)}
  header{position:sticky;top:0;z-index:10;background:rgba(246,247,251,.92);backdrop-filter:blur(10px);border-bottom:1px solid var(--stroke)}
  .wrap{max-width:1100px;margin:0 auto;padding:12px 14px}
  h1{margin:0;font-size:15px;letter-spacing:.2px}
  h2{margin:0 0 8px;font-size:16px}
  .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
  .spacer{flex:1}
  .tabs{display:flex;gap:8px;flex-wrap:wrap}
  .tabbtn{
    border:1px solid var(--stroke);
    background:#ffffff;
    color:var(--text);
    padding:10px 12px;
    border-radius:999px;
    cursor:pointer;
    font-weight:700;
    letter-spacing:.2px;
  }
  .tabbtn.active{
    border-color:rgba(31,138,112,.55);
    box-shadow:0 0 0 3px rgba(31,138,112,.14) inset;
    background:rgba(31,138,112,.10);
  }
  .card{
    background:var(--surface);
    border:1px solid var(--stroke);
    border-radius:var(--radius);
    padding:14px;
    box-shadow:0 8px 28px rgba(16,22,36,.06);
  }
  .card.soft{background:var(--surface2)}
  .grid{display:grid;gap:12px}
  @media(min-width:980px){ .grid.two{grid-template-columns:1fr 1fr} }
  label{display:block;font-size:12px;color:var(--muted);margin:0 0 6px}
  input,select{
    width:100%; padding:12px 12px; border-radius:14px;
    background:#ffffff;
    border:1px solid rgba(20,24,33,.18);
    color:var(--text); outline:none;
  }
  input:focus, select:focus{border-color:rgba(31,138,112,.55); box-shadow:0 0 0 3px rgba(31,138,112,.14)}
  .btn{
    padding:12px 12px;border-radius:14px;border:1px solid rgba(20,24,33,.16);
    background:rgba(31,138,112,.12);color:var(--text);cursor:pointer;
    font-weight:800;
  }
  .btn:hover{filter:brightness(1.03)}
  .btn.ok{background:rgba(23,143,99,.14)}
  .btn.ghost{background:#ffffff}
  .btn.danger{background:rgba(214,69,69,.12)}
  .hint{font-size:12px;color:var(--muted);line-height:1.45}
  .msg{margin-top:10px;padding:10px 12px;border-radius:14px;border:1px solid rgba(20,24,33,.14);background:rgba(16,22,36,.03);font-size:13px}
  .msg.ok{border-color:rgba(23,143,99,.28); background:rgba(23,143,99,.08)}
  .msg.err{border-color:rgba(214,69,69,.28); background:rgba(214,69,69,.08)}
  .msg.warn{border-color:rgba(184,131,0,.28); background:rgba(184,131,0,.08)}
  .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace}
  .right{display:flex;gap:8px;justify-content:flex-end;flex-wrap:wrap}
  .pill{display:inline-flex;gap:6px;align-items:center;padding:6px 10px;border-radius:999px;background:rgba(16,22,36,.03);border:1px solid rgba(20,24,33,.12);font-size:12px}
  .divider{height:1px;background:rgba(20,24,33,.10);margin:12px 0}
  table{width:100%;border-collapse:collapse;font-size:13px}
  th,td{border-bottom:1px solid rgba(20,24,33,.10);padding:10px 8px;text-align:left;vertical-align:top}
  th{font-size:12px;color:var(--muted);font-weight:800;position:sticky;top:0;background:rgba(255,255,255,.96);backdrop-filter:blur(8px)}
  code{background:rgba(16,22,36,.05);padding:2px 6px;border-radius:8px}
  .step{
    display:flex;gap:10px;align-items:flex-start;
    padding:10px 12px;border-radius:16px;border:1px dashed rgba(20,24,33,.18);
    background:rgba(16,22,36,.02);
    margin-top:10px;
  }
  .step .n{
    width:26px;height:26px;border-radius:999px;
    display:flex;align-items:center;justify-content:center;
    background:rgba(31,138,112,.12);border:1px solid rgba(31,138,112,.25);
    font-weight:900;color:var(--accent);
  }
  .step .t{font-weight:850}
  .step .d{font-size:12px;color:var(--muted);line-height:1.35;margin-top:2px}
  @media(max-width:820px){
    .wrap{max-width:720px}
    .tabbtn{padding:12px 14px;font-size:16px}
    input,select{padding:14px 14px;font-size:16px}
    .btn{padding:14px 14px;font-size:16px}
    .field{min-width:100% !important}
    th{position:static}
  }
  .field{flex:1;min-width:220px}

  /* ===== Operação (Mobile-first) ===== */
  .opMobile .row{align-items:stretch}
  .opMobile .right{justify-content:stretch}
  .opMobile .right .btn{flex:1}
  .opMobile .btn{min-height:48px}
  .opMobile input, .opMobile select{min-height:48px}
  .opMobile .hint{font-size:13px}
  .opMobile h2{font-size:18px}
  .opMobile label{font-size:13px}
  .opMobile .card{padding:14px}
  .opMobile .step{border-style:solid}
  @media(max-width:820px){
    .opMobile .row{flex-direction:column;gap:10px}
    .opMobile .field{min-width:100% !important}
    .opMobile .btn{width:100%}
    .opMobile input, .opMobile select{font-size:18px}
    .opMobile .tabbtn{font-size:16px}
    .opMobile .card{border-radius:18px}
  }


  /* ===== Operação Mobile: menu + ecrã único ===== */
  .opMenuGrid{display:grid;gap:12px}
  .opMenuBtn{display:flex;align-items:center;justify-content:space-between;gap:12px;padding:14px 14px;border:1px solid var(--line);border-radius:16px;background:#fff;cursor:pointer}
  .opMenuBtn .k{font-weight:800}
  .opMenuBtn .s{color:var(--muted);font-size:13px}
  .opTopbar{display:flex;align-items:center;gap:10px;margin-bottom:10px}
  .opBack{border:1px solid var(--line);background:#fff;border-radius:14px;padding:10px 12px;cursor:pointer}
  .opBack:active{transform:scale(.99)}
  @media(max-width:820px){
    .opTabsRow{display:none !important}
    .opMenuBtn{min-height:62px}
    .opMenuBtn .k{font-size:18px}
  }


  /* ===== Login Fullscreen Gate ===== */
  #appShell{display:none}
  #loginScreen{position:fixed;inset:0;background:#fff;display:flex;align-items:center;justify-content:center;padding:18px;z-index:9999}
  #loginCard{width:min(520px,100%);border:1px solid var(--line);border-radius:20px;padding:18px;box-shadow:var(--shadow)}
  #loginCard h2{margin:0 0 6px}
  #loginCard .hint{margin:0 0 12px}
  #userCorner{display:none;gap:10px;align-items:center}
  @media(max-width:820px){
    #loginCard{border-radius:22px}
  }



/* MOBILE BOOST */
@media (max-width: 820px){
  :root{ --pad: 14px; }
  body{ font-size: 16px; }
  .app{ padding: 10px; }
  .card{ border-radius: 16px; }
  .tabs{ position: sticky; top: 0; z-index: 50; background: rgba(255,255,255,.95); backdrop-filter: blur(8px); }
  .tabbtn{ padding: 12px 12px; font-size: 15px; }
  input, select, textarea{ font-size: 18px; height: 48px; }
  textarea{ height: auto; }
  .btn{ min-height: 48px; padding: 12px 14px; font-size: 16px; }
  .row{ gap: 10px; }
  .hint{ font-size: 13px; line-height: 1.3; }
}

  :root{
    --bg:#f6f7fb;
    --surface:#ffffff;
    --surface2:#fbfbfe;
    --stroke:rgba(20,24,33,.12);
    --text:#101624;
    --muted:#5b677a;
    --accent:#1f8a70;   /* verde/teal */
    --ok:#178f63;
    --danger:#d64545;
    --warn:#b88300;
    --radius:16px;
  }
  *{box-sizing:border-box;font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial,sans-serif}
  body{margin:0;background:linear-gradient(180deg,var(--bg),#ffffff);color:var(--text)}
  header{position:sticky;top:0;z-index:10;background:rgba(246,247,251,.92);backdrop-filter:blur(10px);border-bottom:1px solid var(--stroke)}
  .wrap{max-width:1100px;margin:0 auto;padding:12px 14px}
  h1{margin:0;font-size:15px;letter-spacing:.2px}
  h2{margin:0 0 8px;font-size:16px}
  .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
  .spacer{flex:1}
  .tabs{display:flex;gap:8px;flex-wrap:wrap}
  .tabbtn{
    border:1px solid var(--stroke);
    background:#ffffff;
    color:var(--text);
    padding:10px 12px;
    border-radius:999px;
    cursor:pointer;
    font-weight:700;
    letter-spacing:.2px;
  }
  .tabbtn.active{
    border-color:rgba(31,138,112,.55);
    box-shadow:0 0 0 3px rgba(31,138,112,.14) inset;
    background:rgba(31,138,112,.10);
  }
  .card{
    background:var(--surface);
    border:1px solid var(--stroke);
    border-radius:var(--radius);
    padding:14px;
    box-shadow:0 8px 28px rgba(16,22,36,.06);
  }
  .card.soft{background:var(--surface2)}
  .grid{display:grid;gap:12px}
  @media(min-width:980px){ .grid.two{grid-template-columns:1fr 1fr} }
  label{display:block;font-size:12px;color:var(--muted);margin:0 0 6px}
  input,select{
    width:100%; padding:12px 12px; border-radius:14px;
    background:#ffffff;
    border:1px solid rgba(20,24,33,.18);
    color:var(--text); outline:none;
  }
  input:focus, select:focus{border-color:rgba(31,138,112,.55); box-shadow:0 0 0 3px rgba(31,138,112,.14)}
  .btn{
    padding:12px 12px;border-radius:14px;border:1px solid rgba(20,24,33,.16);
    background:rgba(31,138,112,.12);color:var(--text);cursor:pointer;
    font-weight:800;
  }
  .btn:hover{filter:brightness(1.03)}
  .btn.ok{background:rgba(23,143,99,.14)}
  .btn.ghost{background:#ffffff}
  .btn.danger{background:rgba(214,69,69,.12)}
  .hint{font-size:12px;color:var(--muted);line-height:1.45}
  .msg{margin-top:10px;padding:10px 12px;border-radius:14px;border:1px solid rgba(20,24,33,.14);background:rgba(16,22,36,.03);font-size:13px}
  .msg.ok{border-color:rgba(23,143,99,.28); background:rgba(23,143,99,.08)}
  .msg.err{border-color:rgba(214,69,69,.28); background:rgba(214,69,69,.08)}
  .msg.warn{border-color:rgba(184,131,0,.28); background:rgba(184,131,0,.08)}
  .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace}
  .right{display:flex;gap:8px;justify-content:flex-end;flex-wrap:wrap}
  .pill{display:inline-flex;gap:6px;align-items:center;padding:6px 10px;border-radius:999px;background:rgba(16,22,36,.03);border:1px solid rgba(20,24,33,.12);font-size:12px}
  .divider{height:1px;background:rgba(20,24,33,.10);margin:12px 0}
  table{width:100%;border-collapse:collapse;font-size:13px}
  th,td{border-bottom:1px solid rgba(20,24,33,.10);padding:10px 8px;text-align:left;vertical-align:top}
  th{font-size:12px;color:var(--muted);font-weight:800;position:sticky;top:0;background:rgba(255,255,255,.96);backdrop-filter:blur(8px)}
  code{background:rgba(16,22,36,.05);padding:2px 6px;border-radius:8px}
  .step{
    display:flex;gap:10px;align-items:flex-start;
    padding:10px 12px;border-radius:16px;border:1px dashed rgba(20,24,33,.18);
    background:rgba(16,22,36,.02);
    margin-top:10px;
  }
  .step .n{
    width:26px;height:26px;border-radius:999px;
    display:flex;align-items:center;justify-content:center;
    background:rgba(31,138,112,.12);border:1px solid rgba(31,138,112,.25);
    font-weight:900;color:var(--accent);
  }
  .step .t{font-weight:850}
  .step .d{font-size:12px;color:var(--muted);line-height:1.35;margin-top:2px}
  @media(max-width:820px){
    .wrap{max-width:720px}
    .tabbtn{padding:12px 14px;font-size:16px}
    input,select{padding:14px 14px;font-size:16px}
    .btn{padding:14px 14px;font-size:16px}
    .field{min-width:100% !important}
    th{position:static}
  }
  .field{flex:1;min-width:220px}

  /* ===== Operação (Mobile-first) ===== */
  .opMobile .row{align-items:stretch}
  .opMobile .right{justify-content:stretch}
  .opMobile .right .btn{flex:1}
  .opMobile .btn{min-height:48px}
  .opMobile input, .opMobile select{min-height:48px}
  .opMobile .hint{font-size:13px}
  .opMobile h2{font-size:18px}
  .opMobile label{font-size:13px}
  .opMobile .card{padding:14px}
  .opMobile .step{border-style:solid}
  @media(max-width:820px){
    .opMobile .row{flex-direction:column;gap:10px}
    .opMobile .field{min-width:100% !important}
    .opMobile .btn{width:100%}
    .opMobile input, .opMobile select{font-size:18px}
    .opMobile .tabbtn{font-size:16px}
    .opMobile .card{border-radius:18px}
  }


  /* ===== Operação Mobile: menu + ecrã único ===== */
  .opMenuGrid{display:grid;gap:12px}
  .opMenuBtn{display:flex;align-items:center;justify-content:space-between;gap:12px;padding:14px 14px;border:1px solid var(--line);border-radius:16px;background:#fff;cursor:pointer}
  .opMenuBtn .k{font-weight:800}
  .opMenuBtn .s{color:var(--muted);font-size:13px}
  .opTopbar{display:flex;align-items:center;gap:10px;margin-bottom:10px}
  .opBack{border:1px solid var(--line);background:#fff;border-radius:14px;padding:10px 12px;cursor:pointer}
  .opBack:active{transform:scale(.99)}
  @media(max-width:820px){
    .opTabsRow{display:none !important}
    .opMenuBtn{min-height:62px}
    .opMenuBtn .k{font-size:18px}
  }


  /* ===== Login Fullscreen Gate ===== */
  #appShell{display:none}
  #loginScreen{position:fixed;inset:0;background:#fff;display:flex;align-items:center;justify-content:center;padding:18px;z-index:9999}
  #loginCard{width:min(520px,100%);border:1px solid var(--line);border-radius:20px;padding:18px;box-shadow:var(--shadow)}
  #loginCard h2{margin:0 0 6px}
  #loginCard .hint{margin:0 0 12px}
  #userCorner{display:none;gap:10px;align-items:center}
  @media(max-width:820px){
    #loginCard{border-radius:22px}
  }



/* MOBILE BOOST */
@media (max-width: 820px){
  :root{ --pad: 14px; }
  body{ font-size: 16px; }
  .app{ padding: 10px; }
  .card{ border-radius: 16px; }
  .tabs{ position: sticky; top: 0; z-index: 50; background: rgba(255,255,255,.95); backdrop-filter: blur(8px); }
  .tabbtn{ padding: 12px 12px; font-size: 15px; }
  input, select, textarea{ font-size: 18px; height: 48px; }
  textarea{ height: auto; }
  .btn{ min-height: 48px; padding: 12px 14px; font-size: 16px; }
  .row{ gap: 10px; }
  .hint{ font-size: 13px; line-height: 1.3; }
}
</style>
  <script src="https://cdn.jsdelivr.net/npm/jsbarcode@3.11.6/dist/JsBarcode.all.min.js"></script>
</head>
<body>
<div id="loginScreen">
  <div id="loginCard">
    <h2>Sign in</h2>
    <div class="hint">Precisas de autenticação para usar o sistema.</div>

    <div class="row">
      <div class="field" style="flex:1;min-width:220px">
        <label>Email</label>
        <input id="loginEmail" placeholder="email@empresa.com" autocomplete="username" />
      </div>
      <div class="field" style="flex:1;min-width:220px">
        <label>Password</label>
        <input id="loginPass" type="password" placeholder="••••••••" autocomplete="current-password" />
      </div>
    </div>

    <div class="row" style="margin-top:10px;justify-content:space-between;align-items:center">
      <button class="btn ok" id="btnLogin">Entrar</button>
      <div id="authMsg" style="flex:1;min-width:240px;margin-left:10px"></div>
    </div>

    <div class="hint" style="margin-top:12px">
      Perfis: <b>@admin.com</b> (Admin+Operação) • <b>@wh.com</b> (Operação+Consulta).<br>
      ⚠️ Abre sempre em <b>HTTPS</b> (Firebase Hosting) ou em <code>http://localhost</code>.
    </div>
  </div>
</div>

<div id="appShell">
<header>
  <div class="wrap">
    <div class="row" style="justify-content:space-between;align-items:center">
      <h1>Warehouse — Operations & Control</h1>
      <div class="row" id="userCorner">
        <span class="pill" id="authPill">Auth: —</span>
        <button class="btn danger" id="btnLogout">Logout</button>
        <button class="btn ghost" id="btnReload">Recarregar</button>
      </div>
    </div>

    <div class="row" style="margin-top:10px;justify-content:space-between">
      <div class="tabs" id="tabs"></div>
    </div>
  </div>
</header>

<div class="wrap">
  <div id="view"></div>
</div>
</div>

<script type="module">
  // ===== Debug Overlay (evita ecrã branco) =====
  function showFatal(err){
    try{
      console.error(err);
      const msg = (err && (err.message||err.reason||err))+"";
      const box = document.getElementById("authMsg") || document.getElementById("view") || document.body;
      if(box){
        const div = document.createElement("div");
        div.className = "msg err";
        div.style.marginTop = "12px";
        div.innerHTML = "Erro: " + (msg.replace(/[&<>]/g, c=>({ "&":"&amp;","<":"&lt;",">":"&gt;"}[c])));
        box.prepend(div);
      }
      const ls = document.getElementById("loginScreen");
      const as = document.getElementById("appShell");
      if(ls) ls.style.display = "flex";
      if(as) as.style.display = "none";
    }catch(e){}
  }
  window.addEventListener("error", (e)=>showFatal(e.error||e.message||e));
  window.addEventListener("unhandledrejection", (e)=>showFatal(e.reason||e));

  // ===== Firebase config (já preenchido) =====
  const firebaseConfig = {
    apiKey: "AIzaSyCFnPU0CZPtcMqPi_aq2XJVQodIgWZV4h0",
    authDomain: "posicoeswh.firebaseapp.com",
    projectId: "posicoeswh",
    storageBucket: "posicoeswh.firebasestorage.app",
    messagingSenderId: "234070238679",
    appId: "1:234070238679:web:4ef11f08523c3b71055792",
  };

  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.8.0/firebase-app.js";
  import { getAuth, onAuthStateChanged, signInWithEmailAndPassword, signOut } from "https://www.gstatic.com/firebasejs/10.8.0/firebase-auth.js";
  import {
    getFirestore, doc, getDoc, setDoc, deleteDoc, collection, getDocs, query, where, orderBy, limit, updateDoc,
    writeBatch, runTransaction, serverTimestamp
  } from "https://www.gstatic.com/firebasejs/10.8.0/firebase-firestore.js";

  const app = initializeApp(firebaseConfig);
  const auth = getAuth(app);
  const db = getFirestore(app);

  // ===== Coleções =====
  const COL_PRODUCTS = "products";
  const COL_POSITIONS = "positions";
  const COL_STOCK = "stockItems";
  const COL_MOVEMENTS = "movements";
  const COL_CONFIG = "config";

  // stockItems/{positionId__productId__palletId}
  // { positionId, productId, palletBarcode, slotType:"PICKING"|"COMPLETA", qtyUnits, qtyPallets, updatedAt }

  const $ = (id)=>document.getElementById(id);
  const tabsEl = $("tabs");
  const viewEl = $("view");
  const authPill = $("authPill");

  const appShell = document.getElementById("appShell");
  const loginScreen = document.getElementById("loginScreen");
  const userCorner = document.getElementById("userCorner");

  function setGate(mode){
    const ok = (mode==="app");
    if(loginScreen) loginScreen.style.display = ok ? "none" : "flex";
    if(appShell) appShell.style.display = ok ? "block" : "none";
    if(userCorner) userCorner.style.display = ok ? "flex" : "none";
  }

  
  
  const DEFAULT_STATUSES = ["NORMAL","PACKED"]; // PACKED = "EMBALADO"
  let _statusesCache = null;

  async function loadStatuses(){
    try{
      const snap = await getDoc(doc(db, COL_CONFIG, "app"));
      if(snap.exists()){
        const arr = snap.data().statuses;
        if(Array.isArray(arr) && arr.length){
          _statusesCache = arr.map(x=>String(x||"").trim()).filter(Boolean);
          return _statusesCache;
        }
      }
    }catch(e){}
    _statusesCache = DEFAULT_STATUSES.slice();
    return _statusesCache;
  }

  async function ensureStatusesLoaded(){
    return _statusesCache ? _statusesCache : await loadStatuses();
  }

  async function saveStatuses(statuses){
    const user = auth.currentUser;
    if(!user) throw new Error("Not signed in.");
    if(!canAdmin(user)) throw new Error("No permission.");
    const clean = (statuses||[]).map(x=>String(x||"").trim()).filter(Boolean);
    if(!clean.length) throw new Error("Statuses list is empty.");
    await setDoc(doc(db, COL_CONFIG, "app"), { statuses: clean, updatedAt: serverTimestamp() }, { merge:true });
    _statusesCache = clean;
    return clean;
  }
const DEFAULT_ORIGINS = ["NEW","RETURNS","TRUCK","PACKED"]; // PACKED = "EMBALADO"
  let _originsCache = null;

  async function loadOrigins(){
    try{
      const snap = await getDoc(doc(db, COL_CONFIG, "app"));
      if(snap.exists()){
        const arr = snap.data().origins;
        if(Array.isArray(arr) && arr.length) {
          _originsCache = arr.map(x=>String(x||"").trim()).filter(Boolean);
          return _originsCache;
        }
      }
    }catch(e){ /* ignore */ }
    _originsCache = DEFAULT_ORIGINS.slice();
    return _originsCache;
  }

  async function ensureOriginsLoaded(){
    if(_originsCache) return _originsCache;
    return await loadOrigins();
  }

  async function saveOrigins(origins){
    const user = auth.currentUser;
    if(!user) throw new Error("Not signed in.");
    if(!isAdminUser(user)) throw new Error("No permission.");
    const clean = (origins||[]).map(x=>String(x||"").trim()).filter(Boolean);
    if(clean.length===0) throw new Error("Origins list is empty.");
    await setDoc(doc(db, COL_CONFIG, "app"), { origins: clean, updatedAt: serverTimestamp() }, { merge:true });
    _originsCache = clean;
    return clean;
  }
const state = { tab: "operacao", op:"menu", user: null, cache: { products: [], positions: [] } };

  // ===== Perfis por domínio =====
  function emailOfUser(u){
    var e = (u && (u.email || (u.providerData && u.providerData[0] && u.providerData[0].email) ) ) || "";
    return String(e||"").toLowerCase().trim();
  }
  function isAdminUser(u){ return /@admin\.com$/.test(emailOfUser(u)); }
  function isWhUser(u){ return /@wh\.com$/.test(emailOfUser(u)); }
  function isAllowedUser(u){ return /^(joana\.coimbra\.fulfillment@gmail\.com)$/i.test(emailOfUser(u)); }
  function canOperate(u){ return !!u && (isAdminUser(u) || isWhUser(u) || isAllowedUser(u)); }
  function canAdmin(u){ return !!u && isAdminUser(u); }

  
  function displayUser(m){
    return (m.userEmail || m.userLabel || m.userName || m.user || m.userId || "");
  }

  function statusOptions(list, includeKeep){
    var arr = (list && list.length) ? list : ["NORMAL","PACKED"];
    var opt = "";
    if(includeKeep) opt += '<option value="">(keep)</option>';
    for(var i=0;i<arr.length;i++){
      var s = String(arr[i]||"").trim();
      if(!s) continue;
      opt += '<option value="'+esc(s)+'">'+esc(s)+'</option>';
    }
    return opt;
  }
function esc(s){ return (s ?? "").toString().replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c])); }
  function msgBox(html, type=""){ return `<div class="msg ${type}">${html}</div>`; }
  function normalizeBarcode(s){ return (s ?? "").toString().trim(); }

  function encodeKey(str){
    const u8 = new TextEncoder().encode(str);
    let bin = "";
    u8.forEach(b => bin += String.fromCharCode(b));
    const b64 = btoa(bin);
    return b64.replace(/=+$/,"").replace(/\+/g,"-").replace(/\//g,"_");
  }
  function palletIdFromBarcode(palletBarcode){
    const b = normalizeBarcode(palletBarcode);
    return b ? encodeKey(b) : "nopallet";
  }
  function stockKey(positionId, productId, palletId){ return `${positionId}__${productId}__${palletId}`; }

  async function getProductByBarcode(barcode){
    const b = normalizeBarcode(barcode);
    if(!b) return null;
    const snap = await getDoc(doc(db, COL_PRODUCTS, encodeKey(b)));
    return snap.exists() ? ({ id: snap.id, ...snap.data() }) : null;
  }
  async function getPositionByBarcode(barcode){
    const b = normalizeBarcode(barcode);
    if(!b) return null;
    const snap = await getDoc(doc(db, COL_POSITIONS, encodeKey(b)));
    return snap.exists() ? ({ id: snap.id, ...snap.data() }) : null;
  }

  async function getPositionByInput(input){
    const raw = String(input||"").trim();
    if(!raw) return null;

    // 1) Try as barcode (document id = encoded barcode)
    const b = normalizeBarcode(raw) || raw;
    try{
      const snap = await getDoc(doc(db, COL_POSITIONS, encodeKey(b)));
      if(snap.exists()) return ({ id: snap.id, ...snap.data() });
    }catch(_e){}

    // 2) Try as location code (field: code) - exact and uppercase
    const code1 = raw;
    const code2 = raw.toUpperCase();
    for(const code of [code1, code2]){
      const q = query(collection(db, COL_POSITIONS), where("code","==",code), limit(1));
      const qs = await getDocs(q);
      if(!qs.empty){
        const d = qs.docs[0];
        return ({ id: d.id, ...d.data() });
      }
    }
    return null;
  }

  // Back-compat
  function getPositionByCode(code){
    return getPositionByInput(code);
  }




  async function upsertProduct({name, barcode}){
    const b = normalizeBarcode(barcode);
    if(!name || !b) throw new Error("Nome e barcode são obrigatórios.");
    await setDoc(doc(db, COL_PRODUCTS, encodeKey(b)), { name: name.trim(), barcode: b, updatedAt: serverTimestamp() }, { merge:true });
  }
  async function upsertPosition({code, barcode}){
    const b = normalizeBarcode(barcode);
    if(!code || !b) throw new Error("Location e barcode são obrigatórios.");
    await setDoc(doc(db, COL_POSITIONS, encodeKey(b)), { code: code.trim().toUpperCase(), barcode: b, updatedAt: serverTimestamp() }, { merge:true });
  }

  async function loadAdminLists(){
    const pSnap = await getDocs(collection(db, COL_PRODUCTS));
    state.cache.products = pSnap.docs.map(d=>({id:d.id, ...d.data()}))
      .sort((a,b)=>(a.name||"").localeCompare(b.name||"", "pt", {sensitivity:"base"}));
    const sSnap = await getDocs(collection(db, COL_POSITIONS));
    state.cache.positions = sSnap.docs.map(d=>({id:d.id, ...d.data()}))
      .sort((a,b)=>(a.code||"").localeCompare(b.code||"", "pt", {sensitivity:"base"}));
  }

  function parseCSV(text){
    const lines = text.replace(/\r\n/g,"\n").replace(/\r/g,"\n").split("\n").filter(l=>l.trim().length>0);
    if(lines.length===0) return [];
    const hdr = lines[0];
    const delim = (hdr.split(";").length > hdr.split(",").length) ? ";" : ",";
    return lines.map(line => parseCSVLine(line, delim));
  }
  function parseCSVLine(line, delim){
    const out = []; let cur=""; let inQ=false;
    for(let i=0;i<line.length;i++){
      const ch=line[i];
      if(ch === '"'){
        if(inQ && line[i+1] === '"'){ cur += '"'; i++; }
        else inQ = !inQ;
      }else if(ch === delim && !inQ){
        out.push(cur); cur="";
      }else cur += ch;
    }
    out.push(cur);
    return out;
  }

  // ===== Stock ops =====
  async function addStock(positionId, productId, palletBarcode, slotType, deltaUnits, deltaPallets, origin){
    const user = auth.currentUser;
    if(!user) throw new Error("Not signed in.");
    if(!canOperate(user)) throw new Error("No permission.");

    const palletId = palletIdFromBarcode(palletBarcode);
    const key = stockKey(positionId, productId, palletId);
    const ref = doc(db, COL_STOCK, key);
    const pbc = normalizeBarcode(palletBarcode);

    const dU = Number(deltaUnits || 0);
    const dP = Number(deltaPallets || 0);

    // PICKING fica sempre com 1 UND (guarda palete e ignora quantidades inseridas)
    const pickingFixedOne = (String(slotType||"").toUpperCase()==="PICKING"); // PICKING_FIXED_ONE

    const org = (origin||"").toString().trim().toUpperCase();

    await runTransaction(db, async (tx)=>{
      const snap = await tx.get(ref);
      const curU = snap.exists() ? Number(snap.data().qtyUnits || 0) : 0;
      const curP = snap.exists() ? Number(snap.data().qtyPallets || 0) : 0;

      let nextU = curU + dU;
      let nextP = curP + dP;
      if(pickingFixedOne){
        nextU = 1;
        nextP = curP + dP;
        if(nextP < 0) throw new Error("Stock insuficiente (PAL).");
      }

      if(!pickingFixedOne){
        if(nextU < 0) throw new Error("Stock insuficiente (UND).");
        if(nextP < 0) throw new Error("Stock insuficiente (Pallets).");
      }

      if(nextU === 0 && nextP === 0 && !pickingFixedOne){
        tx.delete(ref);
      }else{
        tx.set(ref, {
          positionId, productId,
          palletBarcode: pbc || "",
          slotType: slotType || "PICKING",
          qtyUnits: nextU,
          qtyPallets: nextP,
          origin: (org==="NEW"||org==="RETURNS") ? org : (snap.exists() ? (snap.data().origin||"") : ""),
          updatedAt: serverTimestamp()
        }, { merge:true });
      }

      const mvRef = doc(collection(db, COL_MOVEMENTS));
      tx.set(mvRef, {
        type: (dU >= 0 || dP >= 0) ? "ARRUMAR" : "RETIRAR",
        ts: serverTimestamp(),
        userId: user.uid,
        userEmail: (user.email||""),
        userLabel: ((user.email||"").split("@")[0]||""),
        userEmail: (user.email||""),
        userLabel: ((user.email||"").split("@")[0]||""),
        positionId,
        productId,
        palletBarcode: pbc || "",
        slotType: slotType || "PICKING",
        qtyUnits: Math.abs(dU),
        qtyPallets: Math.abs(dP),
        qtyUnitsRequested: Math.abs(dU),
        qtyPalletsRequested: Math.abs(dP),
        qtyUnitsApplied: pickingFixedOne ? 1 : Math.abs(dU),
        qtyPalletsApplied: Math.abs(dP),
        pickingIgnoredUnits: pickingFixedOne,
        pickingFixed: pickingFixedOne,
        origin: ((dU>=0 || dP>=0) && (org==="NEW"||org==="RETURNS")) ? org : "",
      });
    });
  }

  async function ensurePickingPallet(positionId, productId, palletBarcode){
    const palletId = palletIdFromBarcode(palletBarcode);
    const key = stockKey(positionId, productId, palletId);
    const ref = doc(db, COL_STOCK, key);
    const pbc = normalizeBarcode(palletBarcode);
    await setDoc(ref, {
      positionId, productId,
      palletBarcode: pbc || "",
      slotType: "PICKING",
      qtyUnits: 1,
      updatedAt: serverTimestamp()
    }, { merge:true });
  }

  async function transferReplenish(fromPositionId, toPositionId, productId, srcPallet, dstPallet, qtyUnits, qtyPallets){
    const user = auth.currentUser;
    if(!user) throw new Error("Not signed in.");
    if(!canOperate(user)) throw new Error("No permission.");

    const srcPbc = normalizeBarcode(srcPallet);
    let dstPbc = normalizeBarcode(dstPallet);
    if(!srcPbc) throw new Error("Falta palete de origem.");
    // Destino (PICKING): se não indicar palete, cria uma palete virtual por produto
    if(!dstPbc) dstPbc = "PICK-"+String(productId||"").slice(0,20);

    const srcPid = palletIdFromBarcode(srcPbc);
    const srcKey = stockKey(fromPositionId, productId, srcPid);
    const srcRef = doc(db, COL_STOCK, srcKey);

    // destino PICKING (palete virtual)
    const dstPid = palletIdFromBarcode(dstPbc);
    const dstKey = stockKey(toPositionId, productId, dstPid);
    const dstRef = doc(db, COL_STOCK, dstKey);

    const qU = Math.floor(Number(qtyUnits||0));
    const qP = Math.floor(Number(qtyPallets||0));
    if(!(qU>0 || qP>0)) throw new Error("Falta quantidade.");

    await runTransaction(db, async (tx)=>{
      // ✅ Firestore: todas as leituras ANTES de quaisquer escritas
      const [snap, dstSnap] = await Promise.all([tx.get(srcRef), tx.get(dstRef)]);

      if(!snap.exists()) throw new Error("Pallet de origem não existe no stock.");
      const curU = Number(snap.data().qtyUnits||0);
      const curP = Number(snap.data().qtyPallets||0);

      const nextU = curU - qU;
      const nextP = curP - qP;
      if(nextU < 0) throw new Error("Stock insuficiente (UND).");
      if(nextP < 0) throw new Error("Stock insuficiente (Pallets).");

      // ler destino (já lido acima) e calcular paletes
      const curDstP = dstSnap.exists() ? Number(dstSnap.data().qtyPallets || 0) : 0;
      const nextDstP = curDstP + qP;
      if(nextDstP < 0) throw new Error("Stock insuficiente (PAL) no destino.");

      // === Escritas (depois das leituras) ===
      if(nextU===0 && nextP===0){
        tx.delete(srcRef);
      }else{
        tx.set(srcRef, { qtyUnits: nextU, qtyPallets: nextP, updatedAt: serverTimestamp() }, { merge:true });
      }

      // destino PICKING: manter sempre 1 UND
      tx.set(dstRef, {
        positionId: toPositionId, productId,
        palletBarcode: dstPbc,
        slotType: "PICKING",
        qtyUnits: 1,
        qtyPallets: nextDstP,
        updatedAt: serverTimestamp()
      }, { merge:true });

      const mvRef = doc(collection(db, COL_MOVEMENTS));
      tx.set(mvRef, {
        type: "REABASTECER",
        ts: serverTimestamp(),
        userId: user.uid,
        userEmail: (user.email||""),
        userLabel: ((user.email||"").split("@")[0]||""),
        fromPositionId,
        toPositionId,
        productId,
        palletBarcode: srcPbc,
        destPalletBarcode: dstPbc,
        qtyUnits: qU,
        qtyPallets: qP,
        destSlotType: "PICKING",
        destQtyUnitsFixed: 1,
        destQtyPalletsAfter: nextDstP,
        pickingIgnoredUnits: true,
      });
    });
  }


  async function moveStock(fromPositionId, toPositionId, productId, palletBarcode, units, pallets, newStatus){
    const user = auth.currentUser;
    if(!user) throw new Error("Not signed in.");
    if(!canOperate(user)) throw new Error("No permission.");
    if(fromPositionId === toPositionId) throw new Error("Origin = Destino.");

    const palletId = palletIdFromBarcode(palletBarcode);
    const pbc = normalizeBarcode(palletBarcode);

    const u = Number(units || 0);
    const p = Number(pallets || 0);
    if(u <= 0 && p <= 0) throw new Error("Indica UND e/ou Pallets.");

    const fromRef = doc(db, COL_STOCK, stockKey(fromPositionId, productId, palletId));
    const toRef   = doc(db, COL_STOCK, stockKey(toPositionId, productId, palletId));

    await runTransaction(db, async (tx)=>{
      const fromSnap = await tx.get(fromRef);
      const fromU = fromSnap.exists() ? Number(fromSnap.data().qtyUnits||0) : 0;
      const fromP = fromSnap.exists() ? Number(fromSnap.data().qtyPallets||0) : 0;
      if(fromU < u) throw new Error("Stock insuficiente (UND) na origem.");
      if(fromP < p) throw new Error("Stock insuficiente (Pallets) na origem.");
      const fromType = fromSnap.exists() ? (fromSnap.data().slotType || "PICKING") : "PICKING";
      const fromStatus = fromSnap.exists() ? (fromSnap.data().status || "") : "";
      const statusToSet = (typeof newStatus === "string" && newStatus.trim() !== "") ? newStatus.trim() : fromStatus;
      

      const toSnap = await tx.get(toRef);
      const toU = toSnap.exists() ? Number(toSnap.data().qtyUnits||0) : 0;
      const toP = toSnap.exists() ? Number(toSnap.data().qtyPallets||0) : 0;
      const toType = toSnap.exists() ? (toSnap.data().slotType || fromType) : fromType;

      const nextFromU = fromU - u;
      const nextFromP = fromP - p;
      const nextToU = toU + u;
      const nextToP = toP + p;

      if(nextFromU === 0 && nextFromP === 0) tx.delete(fromRef);
      else tx.set(fromRef, { qtyUnits: nextFromU, qtyPallets: nextFromP, updatedAt: serverTimestamp() }, { merge:true });

      tx.set(toRef, {
        positionId: toPositionId,
        productId,
        palletBarcode: pbc || "",
        slotType: toType,
        status: statusToSet,
        qtyUnits: nextToU,
        qtyPallets: nextToP,
        updatedAt: serverTimestamp()
      }, { merge:true });

      const mvRef = doc(collection(db, COL_MOVEMENTS));
      tx.set(mvRef, {
        type: "MUDAR",
        ts: serverTimestamp(),
        userId: user.uid,
        userEmail: (user.email||""),
        userLabel: ((user.email||"").split("@")[0]||""),
        userEmail: (user.email||""),
        userLabel: ((user.email||"").split("@")[0]||""),
        fromPositionId,
        toPositionId,
        productId,
        palletBarcode: pbc || "",
        qtyUnits: u,
        qtyPallets: p,
        status: statusToSet
      });
    });
  }

  async function moveAllFromPosition(fromPositionId, toPositionId){
    const user = auth.currentUser;
    if(!user) throw new Error("Not signed in.");
    if(!canOperate(user)) throw new Error("No permission.");
    if(fromPositionId === toPositionId) throw new Error("Origin = Destino.");

    // "Mover tudo": para todos os stockItems daquela posição (inclui paletes)
    const qy = query(collection(db, COL_STOCK), where("positionId","==", fromPositionId));
    const snap = await getDocs(qy);
    if(snap.empty) throw new Error("Origin sem stock.");

    // Nota: batch com leituras para somar destino (simples)
    const batch = writeBatch(db);
    for(const d of snap.docs){
      const data = d.data();
      const prodId = data.productId;
      const qtyU = Number(data.qtyUnits||0);
      const qtyP = Number(data.qtyPallets||0);
      const pbc = normalizeBarcode(data.palletBarcode || "");
      const palId = palletIdFromBarcode(pbc);

      if(qtyU<=0 && qtyP<=0) continue;

      const toDocRef = doc(db, COL_STOCK, stockKey(toPositionId, prodId, palId));
      const toSnap = await getDoc(toDocRef);
      const toU = toSnap.exists() ? Number(toSnap.data().qtyUnits||0) : 0;
      const toP = toSnap.exists() ? Number(toSnap.data().qtyPallets||0) : 0;
      const slotType = toSnap.exists() ? (toSnap.data().slotType || data.slotType || "PICKING") : (data.slotType || "PICKING");

      batch.set(toDocRef, {
        positionId: toPositionId,
        productId: prodId,
        palletBarcode: pbc || "",
        slotType,
        qtyUnits: toU + qtyU,
        qtyPallets: toP + qtyP,
        updatedAt: serverTimestamp()
      }, { merge:true });

      batch.delete(d.ref);
    }

    const mvRef = doc(collection(db, COL_MOVEMENTS));
    batch.set(mvRef, { type:"MUDAR_TUDO", ts:serverTimestamp(), userId:user.uid, userEmail:(user.email||""), fromPositionId, toPositionId });

    await batch.commit();
  }

  // ===== UI base =====
  function renderTabs(){
    const u = auth.currentUser;
    const showAdmin = canAdmin(u);

    tabsEl.innerHTML = `
      ${showAdmin ? `<button class="tabbtn ${state.tab==="admin"?"active":""}" data-tab="admin">Admin</button>` : ``}
      <button class="tabbtn ${state.tab==="operacao"?"active":""}" data-tab="operacao">Operations</button>
      <button class="tabbtn ${state.tab==="consultar"?"active":""}" data-tab="consultar">Lookup</button>
      <button class="tabbtn ${state.tab==="stock"?"active":""}" data-tab="stock">Stock</button>
      <button class="tabbtn ${state.tab==="movimentos"?"active":""}" data-tab="movimentos">Movements</button>
      <button class="tabbtn ${state.tab==="paletes"?"active":""}" data-tab="paletes">Pallets</button>
    `;

    if(!showAdmin && state.tab==="admin") state.tab = "operacao";

    tabsEl.querySelectorAll("button").forEach(b=>{
      b.onclick = ()=>{ state.tab = b.dataset.tab; render(); };
    });
  }

  function render(){
const u = auth.currentUser;

    if(!u){
      tabsEl.innerHTML = "";
      viewEl.innerHTML = `<div class="card"><h2 style="margin:0 0 8px">Login obrigatório</h2><div class="hint">Faz login no topo para aceder.</div></div>`;
      return;
    }
    if(!canOperate(u)){
      tabsEl.innerHTML = "";
      viewEl.innerHTML = `<div class="card"><h2 style="margin:0 0 8px">No access</h2><div class="hint">Usa email <b>@admin.com</b> ou <b>@wh.com</b>.</div></div>`;
      return;
    }

    renderTabs();

    if(state.tab==="admin"){
      if(!canAdmin(u)){ state.tab="operacao"; renderOperacao(); return; }
      renderAdmin(); return;
    }
    if(state.tab==="consultar"){ renderLookup(); return; }
    if(state.tab==="stock"){ renderStock(); return; }
    if(state.tab==="movimentos"){ renderMovements(); return; }
    if(state.tab==="paletes"){ renderPallets(); return; }
    renderOperacao();
  }

  // ===== Admin (PC): produtos/posições =====
  function renderAdmin(){
    const u = auth.currentUser;
    if(!canAdmin(u)){
      viewEl.innerHTML = `<div class="card">${msgBox("Sem permissões para Admin.", "warn")}</div>`;
      return;
    }

    viewEl.innerHTML = `
      <div class="card">
        <h2 style="margin:0 0 8px">Admin</h2>
        <div class="hint">Products/Locations via CSV + editar.</div>
        <div id="adminMsg">${msgBox(`✅ Logado: <span class="mono">${esc(u.uid)}</span>`, "ok")}</div>
      </div>

      <div class="grid two" style="margin-top:12px">
        <div class="card">
          <h2>Products</h2>
          <div class="row">
            <div class="field">
              <label>Upload CSV (A=Produto, B=Barcode)</label>
              <input type="file" id="pCsv" accept=".csv,text/csv" />
              <div class="hint">1ª linha cabeçalho • delimitador <code>,</code> ou <code>;</code></div>
            </div>
            <div class="field"><label>Nome</label><input id="pName" placeholder="Nome produto" /></div>
            <div class="field"><label>Barcode</label><input id="pBarcode" class="mono" placeholder="Picar/Escrever" /></div>
            <div class="right">
              <button class="btn ok" id="pSave">Guardar</button>
              <button class="btn ghost" id="pReload">Refresh</button>
            <button class="btn ghost" id="pExport">Export Products (CSV ;)</button>
              </div>
          </div>
          <div id="pMsg"></div>
          <div class="divider"></div>
          <div class="row"><div class="field"><label>Search</label><input id="pSearch" placeholder="nome ou barcode" /></div></div>
          <div style="overflow:auto;max-height:420px;margin-top:10px">
            <table><thead><tr><th>Produto</th><th>Barcode</th><th></th></tr></thead><tbody id="pTable"></tbody></table>
          </div>
        </div>

        <div class="card">
          <h2>Locations</h2>
          <div class="row">
            <div class="field">
              <label>Upload CSV (A=Location, B=Barcode)</label>
              <input type="file" id="sCsv" accept=".csv,text/csv" />
              <div class="hint">1ª linha cabeçalho • delimitador <code>,</code> ou <code>;</code></div>
            </div>
            <div class="field"><label>Location</label><input id="sCode" placeholder="Ex.: A01-01" /></div>
            <div class="field"><label>Barcode</label><input id="sBarcode" class="mono" placeholder="Picar/Escrever" /></div>
            <div class="right">
              <button class="btn ok" id="sSave">Guardar</button>
              <button class="btn ghost" id="sReload">Refresh</button>
            </div>
          </div>
          <div id="sMsg"></div>
          <div class="divider"></div>
          <div class="row"><div class="field"><label>Search</label><input id="sSearch" placeholder="posição ou barcode" /></div></div>
          <div style="overflow:auto;max-height:420px;margin-top:10px">
            <table><thead><tr><th>Location</th><th>Barcode</th><th></th></tr></thead><tbody id="sTable"></tbody></table>
          </div>
  
        <div class="card" style="margin-top:12px">
          <h3 style="margin:0 0 6px">Statuses (pallet)</h3>
          <div class="hint">Allowed values for <b>Status</b> (applied to pallets).</div>

          <div class="row" style="margin-top:10px;align-items:flex-end">
            <div class="field" style="flex:1;min-width:240px">
              <label>Status list (one per line)</label>
              <textarea id="sList" rows="4" placeholder="NORMAL&#10;PACKED"></textarea>
            </div>
            <div style="min-width:200px">
              <div class="field">
                <label>Add one</label>
                <input id="sAdd" placeholder="PACKED" />
              </div>
              <div class="row" style="margin-top:8px">
                <button class="btn ghost" id="sReloadBtn">Reload</button>
                <button class="btn ghost" id="sAddBtn">Add</button>
                <button class="btn ok" id="sSaveBtn">Save</button>
              </div>
            </div>
          </div>

          <div id="sMsg" style="margin-top:8px"></div>
        </div>

        <div class="card" style="margin-top:12px">
          <h3 style="margin:0 0 6px">Location barcode generator</h3>
          <div class="hint">Type a location code and generate a barcode to print.</div>
          <div class="row" style="margin-top:10px;gap:8px;align-items:flex-end;flex-wrap:wrap">
            <div class="field" style="min-width:220px;flex:1">
              <label>Location text</label>
              <input id="locBarText" placeholder="A01-01-01" />
            </div>
            <button class="btn ghost" id="locBarGen">Generate</button>
            <button class="btn ok" id="locBarPrint">Print</button>
          </div>
          <div id="locBarWrap" style="margin-top:10px;display:none">
            <div class="hint">Preview</div>
            <div style="padding:10px;border:1px solid var(--line);border-radius:12px;background:#fff;display:inline-block">
              <div id="locBarLabel" style="font-weight:800;margin-bottom:6px"></div>
              <svg id="locBarSvg"></svg>
            </div>
          </div>
          <div id="locBarMsg" style="margin-top:8px"></div>
        </div>
      </div>
      </div>
    `;


    // ---- Origins (Admin-managed list) ----
    // Stored in Firestore: config/app.origins (array of strings)
    viewEl.insertAdjacentHTML("beforeend", `
      <div class="card" style="margin-top:12px">
        <h2>Origins</h2>
        <div class="hint">Manage origin options here (Admin). Operators can only choose existing values in Operations.</div>
        <div class="row">
          <div class="field" style="flex:2">
            <label>Origins (one per line)</label>
            <textarea id="oList" rows="6" style="width:100%;min-height:120px" placeholder="NEW\nRETURNS\nPACKED"></textarea>
            <div class="hint">Tip: keep them short (e.g. <code>PACKED</code>, <code>EMBALADO</code>).</div>
          </div>
          <div class="field" style="flex:1">
            <label>Add origin</label>
            <input id="oAdd" placeholder="e.g. EMBALADO" />
            <div class="right" style="margin-top:10px;gap:8px">
              <button class="btn" id="oAddBtn">Add</button>
              <button class="btn ghost" id="oReloadBtn">Reload</button>
              <button class="btn ok" id="oSaveBtn">Save</button>
            </div>
          </div>
        </div>
        <div id="oMsg"></div>
      </div>
    `);

    async function refreshOriginsUI(){
      try{
        const list = await ensureOriginsLoaded();
        $("oList").value = (list||[]).join("\n");
        $("oMsg").innerHTML = msgBox("✅ Origins loaded.", "ok");
      }catch(err){
        $("oMsg").innerHTML = msgBox("Error: "+esc(err.message), "err");
      }
    }

    $("oAddBtn").onclick = ()=>{
      const v = String($("oAdd").value||"").trim();
      if(!v) return;
      const lines = String($("oList").value||"").split(/\r?\n/).map(x=>x.trim()).filter(Boolean);
      if(lines.indexOf(v)===-1) lines.push(v);
      $("oList").value = lines.join("\n");
      $("oAdd").value = "";
    };
    $("oReloadBtn").onclick = ()=>{ _originsCache=null; refreshOriginsUI();

    // Statuses (Admin) handlers
    const sList = $("sList");
    const sAdd = $("sAdd");
    const sAddBtn = $("sAddBtn");
    const sReloadBtn = $("sReloadBtn");
    const sSaveBtn = $("sSaveBtn");
    const sMsg = $("sMsg");

    async function refreshStatusesUI(){
      try{
        const statuses = await ensureStatusesLoaded();
        if(sList) sList.value = statuses.join("\n");
        if(sMsg) sMsg.innerHTML = msgBox("Loaded.", "ok");
      }catch(err){
        if(sMsg) sMsg.innerHTML = msgBox("Error: "+esc(err.message||err), "err");
      }
    }

    if(sReloadBtn) sReloadBtn.addEventListener("click", refreshStatusesUI);

    if(sAddBtn) sAddBtn.addEventListener("click", ()=>{
      const v = String(sAdd ? sAdd.value : "").trim();
      if(!v) return;
      const lines = String(sList ? sList.value : "").split(/\r?\n/).map(x=>x.trim()).filter(Boolean);
      if(lines.indexOf(v)===-1) lines.push(v);
      if(sList) sList.value = lines.join("\n");
      if(sAdd) sAdd.value = "";
    });

    if(sSaveBtn) sSaveBtn.addEventListener("click", async ()=>{
      try{
        const lines = String(sList ? sList.value : "").split(/\r?\n/).map(x=>x.trim()).filter(Boolean);
        await saveStatuses(lines);
        if(sMsg) sMsg.innerHTML = msgBox("Saved.", "ok");
      }catch(err){
        if(sMsg) sMsg.innerHTML = msgBox("Error: "+esc(err.message||err), "err");
      }
    });

    if(sList) refreshStatusesUI();
 };
    $("oSaveBtn").onclick = async ()=>{
      try{
        const lines = String($("oList").value||"").split(/\r?\n/).map(x=>x.trim()).filter(Boolean);
        await saveOrigins(lines);
        $("oMsg").innerHTML = msgBox("✅ Saved.", "ok");
      }catch(err){
        $("oMsg").innerHTML = msgBox("Error: "+esc(err.message), "err");
      }
    };
    refreshOriginsUI();

    $("pCsv").onchange = async (e)=>{
      const f = e.target.files && e.target.files[0];
      if(!f) return;
      try{
        const rows = parseCSV(await f.text());
        if(rows.length<=1) throw new Error("CSV sem dados.");
        const imported = rows.slice(1).filter(r=>r.length>=2)
          .map(r=>({name:(r[0]||"").trim(), barcode:normalizeBarcode(r[1])}))
          .filter(x=>x.name && x.barcode);

        const batch = writeBatch(db);
        imported.forEach(item=>{
          batch.set(doc(db, COL_PRODUCTS, encodeKey(item.barcode)), {name:item.name, barcode:item.barcode, updatedAt:serverTimestamp()}, {merge:true});
        });
        await batch.commit();
        $("pMsg").innerHTML = msgBox(`✅ Importados/atualizados <b>${imported.length}</b> produtos.`, "ok");
        await loadAdminLists(); renderProductsTable();
      }catch(err){ $("pMsg").innerHTML = msgBox("Erro: "+esc(err.message), "err"); }
      finally{ e.target.value=""; }
    };

    $("pSave").onclick = async ()=>{
      try{
        await upsertProduct({name:$("pName").value, barcode:$("pBarcode").value});
        $("pMsg").innerHTML = msgBox("✅ Guardado.", "ok");
        $("pName").value=""; $("pBarcode").value="";
        await loadAdminLists(); renderProductsTable();
      }catch(err){ $("pMsg").innerHTML = msgBox("Erro: "+esc(err.message), "err"); }
    };
    $("pReload").onclick = async ()=>{ await loadAdminLists(); renderProductsTable(); };
    
    $("pExport").onclick = async ()=>{
      try{
        $("pMsg").innerHTML = msgBox("A exportar produtos...", "");
        await exportProductsCSV();
        $("pMsg").innerHTML = msgBox("✅ Products exportados.", "ok");
      }catch(err){
        $("pMsg").innerHTML = msgBox("Erro: "+esc(err.message), "err");
      }
    };
$("pSearch").oninput = renderProductsTable;

    $("sCsv").onchange = async (e)=>{
      const f = e.target.files && e.target.files[0];
      if(!f) return;
      try{
        const rows = parseCSV(await f.text());
        if(rows.length<=1) throw new Error("CSV sem dados.");
        const imported = rows.slice(1).filter(r=>r.length>=2)
          .map(r=>({code:(r[0]||"").trim(), barcode:normalizeBarcode(r[1])}))
          .filter(x=>x.code && x.barcode);

        const batch = writeBatch(db);
        imported.forEach(item=>{
          batch.set(doc(db, COL_POSITIONS, encodeKey(item.barcode)), {code:item.code, barcode:item.barcode, updatedAt:serverTimestamp()}, {merge:true});
        });
        await batch.commit();
        $("sMsg").innerHTML = msgBox(`✅ Importadas/atualizadas <b>${imported.length}</b> posições.`, "ok");
        await loadAdminLists(); renderPositionsTable();
      }catch(err){ $("sMsg").innerHTML = msgBox("Erro: "+esc(err.message), "err"); }
      finally{ e.target.value=""; }
    };

    $("sSave").onclick = async ()=>{
      try{
        await upsertPosition({code:$("sCode").value, barcode:$("sBarcode").value});
        $("sMsg").innerHTML = msgBox("✅ Guardado.", "ok");
        $("sCode").value=""; $("sBarcode").value="";
        await loadAdminLists(); renderPositionsTable();
      }catch(err){ $("sMsg").innerHTML = msgBox("Erro: "+esc(err.message), "err"); }
    };
    $("sReload").onclick = async ()=>{ await loadAdminLists(); renderPositionsTable(); };
    $("sSearch").oninput = renderPositionsTable;

    (async ()=>{ await loadAdminLists(); renderProductsTable(); renderPositionsTable(); })();

    function renderProductsTable(){
      const term = ($("pSearch").value||"").toLowerCase().trim();
      const list = state.cache.products.filter(p=>{
        const n=(p.name||"").toLowerCase();
        const b=normalizeBarcode(p.barcode).toLowerCase();
        return !term || n.includes(term) || b.includes(term);
      });

      $("pTable").innerHTML = list.map(p=>`
        <tr>
          <td><input data-id="${p.id}" data-k="name" value="${esc(p.name||"")}" /></td>
          <td><input class="mono" data-id="${p.id}" data-k="barcode" value="${esc(p.barcode||"")}" /></td>
          <td style="white-space:nowrap">
            <button class="btn ghost" data-act="save" data-id="${p.id}">Guardar</button>
            <button class="btn danger" data-act="del" data-id="${p.id}">Apagar</button>
          </td>
        </tr>
      `).join("") || `<tr><td colspan="3">Sem produtos.</td></tr>`;

      $("pTable").querySelectorAll("button").forEach(btn=>{
        btn.onclick = async ()=>{
          const id = btn.dataset.id, act = btn.dataset.act;
          try{
            if(act==="del"){
              if(!confirm("Apagar produto?")) return;
              await deleteDoc(doc(db, COL_PRODUCTS, id));
              await loadAdminLists(); renderProductsTable();
              $("pMsg").innerHTML = msgBox("✅ Apagado.", "ok");
            }else{
              const name = $("pTable").querySelector(`input[data-id="${id}"][data-k="name"]`).value.trim();
              const barcode = normalizeBarcode($("pTable").querySelector(`input[data-id="${id}"][data-k="barcode"]`).value);
              if(!name || !barcode) throw new Error("Nome e barcode obrigatórios.");
              const newId = encodeKey(barcode);
              await setDoc(doc(db, COL_PRODUCTS, newId), {name, barcode, updatedAt:serverTimestamp()}, {merge:true});
              if(newId !== id) await deleteDoc(doc(db, COL_PRODUCTS, id));
              await loadAdminLists(); renderProductsTable();
              $("pMsg").innerHTML = msgBox("✅ Guardado.", "ok");
            }
          }catch(err){ $("pMsg").innerHTML = msgBox("Erro: "+esc(err.message), "err"); }
        };
      });
    }

    function renderPositionsTable(){
      const term = ($("sSearch").value||"").toLowerCase().trim();
      const list = state.cache.positions.filter(p=>{
        const c=(p.code||"").toLowerCase();
        const b=normalizeBarcode(p.barcode).toLowerCase();
        return !term || c.includes(term) || b.includes(term);
      });

      $("sTable").innerHTML = list.map(p=>`
        <tr>
          <td><input data-id="${p.id}" data-k="code" value="${esc(p.code||"")}" /></td>
          <td><input class="mono" data-id="${p.id}" data-k="barcode" value="${esc(p.barcode||"")}" /></td>
          <td style="white-space:nowrap">
            <button class="btn ghost" data-act="save" data-id="${p.id}">Guardar</button>
            <button class="btn danger" data-act="del" data-id="${p.id}">Apagar</button>
          </td>
        </tr>
      `).join("") || `<tr><td colspan="3">Sem posições.</td></tr>`;

      $("sTable").querySelectorAll("button").forEach(btn=>{
        btn.onclick = async ()=>{
          const id = btn.dataset.id, act = btn.dataset.act;
          try{
            if(act==="del"){
              if(!confirm("Apagar posição?")) return;
              await deleteDoc(doc(db, COL_POSITIONS, id));
              await loadAdminLists(); renderPositionsTable();
              $("sMsg").innerHTML = msgBox("✅ Apagado.", "ok");
            }else{
              const code = $("sTable").querySelector(`input[data-id="${id}"][data-k="code"]`).value.trim();
              const barcode = normalizeBarcode($("sTable").querySelector(`input[data-id="${id}"][data-k="barcode"]`).value);
              if(!code || !barcode) throw new Error("Location e barcode obrigatórios.");
              const newId = encodeKey(barcode);
              await setDoc(doc(db, COL_POSITIONS, newId), {code, barcode, updatedAt:serverTimestamp()}, {merge:true});
              if(newId !== id) await deleteDoc(doc(db, COL_POSITIONS, id));
              await loadAdminLists(); renderPositionsTable();
              $("sMsg").innerHTML = msgBox("✅ Guardado.", "ok");
            }
          }catch(err){ $("sMsg").innerHTML = msgBox("Erro: "+esc(err.message), "err"); }
        };
      });
    }
  }

  // ===== Operations (mobile simples) =====
  function renderOperacao(){
    viewEl.innerHTML = `
      <div class="opMobile">
      <div class="card">
        <h2 style="margin:0 0 8px">Operations</h2>
        <div class="hint">Put away / Move / Remove / Replenish. (Consulta está no separador “Lookup”)</div>
        <div class="row" style="margin-top:10px">
          <button class="tabbtn ${state.op==="arrumar"?"active":""}" data-op="arrumar">Put away</button>
          <button class="tabbtn ${state.op==="mudar"?"active":""}" data-op="mudar">Move</button>
          <button class="tabbtn ${state.op==="retirar"?"active":""}" data-op="retirar">Remove</button>
          <button class="tabbtn ${state.op==="reabastecer"?"active":""}" data-op="reabastecer">Replenish</button>
          <button class="tabbtn ${state.op==="eliminar"?"active":""}" data-op="eliminar">Delete pallet</button>
        </div>
        <div id="opMsg">${msgBox(`✅ Signed in: <span class="mono">${esc(emailOfUser(auth.currentUser) || auth.currentUser.uid)}</span>`, "ok")}</div>
      </div>
      <div id="opView" style="margin-top:12px"></div>
    `;

    viewEl.querySelectorAll("button[data-op]").forEach(b=>{
      b.onclick = ()=>{ state.op = b.dataset.op; renderOperacao(); };
    });

    renderOperacaoBody();
  }

  function renderOperacaoBody(){
    const opView = $("opView");

    if(state.op==="menu"){
      opView.innerHTML = `
        <div class="card">
          <h2 style="margin:0 0 8px">Operations</h2>
          <div class="hint">Escolhe a operação. No telemóvel abre um painel e no fim volta aqui automaticamente.</div>
          <div class="opMenuGrid" style="margin-top:12px">
            <div class="opMenuBtn" data-go="arrumar"><div><div class="k">Put away</div><div class="s">Criar nova palete</div></div><div>›</div></div>
            <div class="opMenuBtn" data-go="mudar"><div><div class="k">Move</div><div class="s">Mover palete inteira</div></div><div>›</div></div>
            <div class="opMenuBtn" data-go="retirar"><div><div class="k">Remove</div><div class="s">Remove qty de uma palete</div></div><div>›</div></div>
            <div class="opMenuBtn" data-go="reabastecer"><div><div class="k">Replenish</div><div class="s">Mover qty palete → palete</div></div><div>›</div></div>
          </div>
          <div id="opMsg"></div>
        </div>
      `;
      opView.querySelectorAll("[data-go]").forEach(b=>{
        b.onclick = ()=>{ state.op = b.getAttribute("data-go"); renderOperacao(); };
      });
      return;
    }

    

    if(state.op==="arrumar"){
      opView.innerHTML = `
        <div class="card">
          <div class="opTopbar"><button class="opBack" id="opBackBtn">←</button><div style="font-weight:800">Put away</div></div>
          <h2>Put away (Nova Pallet)</h2>
          <div class="hint">Criar uma palete nova: POSIÇÃO → PRODUTO → GERAR/PLICAR PALETE → QTD</div>

          <div class="step">
            <div class="n">1</div>
            <div style="flex:1">
              <div class="t">Location</div>
              <div class="row" style="margin-top:8px">
                <div class="row" style="gap:8px;align-items:flex-end">
                  <div class="field" style="flex:1">
                    <label>LOCATION</label>
                    <input id="aPos" class="mono" inputmode="text" autocapitalize="characters" autocomplete="off" enterkeyhint="done" placeholder="Type or scan location..." />
                    <div class="hint" id="aPosInfo"></div>
                  </div>
                  <button class="btn ghost" id="aPosOk" style="min-width:86px;height:46px;margin-top:22px">OK</button>
                </div>
              </div>
            </div>
          </div>

          <div class="step">
            <div class="n">2</div>
            <div style="flex:1">
              <div class="t">Produto</div>
              <div class="row" style="margin-top:8px">
                <div class="field">
                  <label>PRODUTO</label>
                  <input id="aProd" class="mono" placeholder="Pica o produto..." disabled />
                  <div class="hint" id="aProdInfo"></div>
                </div>
              </div>
            </div>
          </div>

          <div class="step">
            <div class="n">3</div>
            <div style="flex:1">
              <div class="t">Pallet + Quantity</div>

              <div class="row" style="margin-top:8px">
                <div class="field">
                  <label>TIPO</label>
                  <select id="aType" disabled>
                    <option value="COMPLETA" selected>COMPLETA</option>
                    <option value="PICKING">PICKING</option>
                  </select>
                </div>
                <div class="field">
                  <label>ORIGIN</label>
                  <select id="aOrigin" disabled>
                    <option value="NEW" selected>NEW</option>
                    <option value="RETURNS">RETURNS</option>
                  </select>
                </div>
                <div class="field">
                  <label>STATUS (optional)</label>
                  <select id="aStatus" disabled>
                    <option value="" selected>(keep)</option>
                  </select>
                </div>
              </div>

              <div class="row" style="margin-top:8px">
                <div class="field">
                  <label>PALETE (nova)</label>
                  <input id="aPal" class="mono" placeholder="Gerar ou pica a palete..." disabled />
                  <div class="right" style="margin-top:8px">
                    <label class="mini" style="display:flex;align-items:center;gap:8px">
                      <span style="font-size:12px;color:var(--muted)">Qtd</span>
                      <input id="aGenQty" type="number" min="1" step="1" value="1" style="width:84px" />
                    </label>
                    <button class="btn ghost" id="aGenPal" disabled>Gerar</button>
                    <button class="btn ghost" id="aPrintPal" disabled>Imprimir</button>
                  </div>
                </div>
              </div>

              <div class="row" style="margin-top:8px">
                <div class="field">
                  <label>UND</label>
                  <input id="aQtyU" type="number" min="0" step="1" placeholder="0" disabled />
                </div>
                <div class="field">
                  <label>PALETES</label>
                  <input id="aQtyP" type="number" min="0" step="1" placeholder="0" disabled />
                </div>
              </div>

              <div class="right" style="margin-top:10px">
                <button class="btn ghost" id="aClear">Clear</button>
                <button class="btn ok" id="aOk" disabled>Criar</button>
              </div>

              <div id="aMsg"></div>
            </div>
          </div>
        </div>
`;
      setupArrumar();
    }

    if(state.op==="retirar"){
      opView.innerHTML = `
        <div class="card">
          <div class="opTopbar"><button class="opBack" id="opBackBtn">←</button><div style="font-weight:800">Remove</div></div>
          <h2>Remove (de uma Pallet)</h2>
          <div class="hint">PALETE → QTD a retirar</div>

          <div class="step">
            <div class="n">1</div>
            <div style="flex:1">
              <div class="t">Pallet</div>
              <div class="row" style="margin-top:8px">
                <div class="field">
                  <label>PALETE</label>
                  <input id="rPal" class="mono" placeholder="Pica a palete..." />
                  <div class="hint" id="rPalInfo"></div>
                </div>
              </div>

              <div class="row" style="margin-top:8px">
                <div class="field">
                  <label>ORIGEM (auto)</label>
                  <input id="rPos" class="mono" placeholder="Origin..." disabled />
                </div>
              </div>
              <div class="row" style="margin-top:8px">
                <div class="field">
                  <label>PRODUTO (auto)</label>
                  <input id="rProd" class="mono" placeholder="Produto..." disabled />
                </div>
              </div>
            </div>
          </div>

          <div class="step">
            <div class="n">2</div>
            <div style="flex:1">
              <div class="t">Quantity</div>
              <div class="row" style="margin-top:8px">
                <div class="field">
                  <label>UNITS</label>
                  <input id="rQtyU" type="number" min="0" step="1" placeholder="0" disabled />
                </div>
                <div class="field">
                  <label>PALLETS</label>
                  <input id="rQtyP" type="number" min="0" step="1" placeholder="0" disabled />
                </div>
              </div>
              <div class="row" style="margin-top:8px">
                <div class="field">
                  <label>STATUS (optional)</label>
                  <select id="rStatus" disabled><option value="" selected>(keep)</option></select>
                </div>
              </div>

              <!-- manter compat -->
              <button id="rOk" style="display:none"></button>
              <button id="rClear" style="display:none"></button>

              <div class="right" style="margin-top:10px">
                <button class="btn ghost" id="rClear2">Clear</button>
                <button class="btn ok" id="rDo" disabled>Remove</button>
              </div>

              <div id="rMsg"></div>
            </div>
          </div>
        </div>
`;
      setupRemove();
    }

    if(state.op==="mudar"){
      opView.innerHTML = `
        <div class="card">
          <div class="opTopbar"><button class="opBack" id="opBackBtn">←</button><div style="font-weight:800">Move</div></div>
          <h2>Move (Mover Pallet)</h2>
          <div class="hint">Mover a palete inteira: PALETE → DESTINO</div>

          <div class="step">
            <div class="n">1</div>
            <div style="flex:1">
              <div class="t">Pallet</div>
              <div class="row" style="margin-top:8px">
                <div class="field">
                  <label>PALETE</label>
                  <input id="mPal" class="mono" placeholder="Pica a palete..." />
                  <div class="hint" id="mPalInfo"></div>
                </div>
              </div>
              <div class="row" style="margin-top:8px">
                <div class="field">
                  <label>ORIGEM (auto)</label>
                  <input id="mFrom" class="mono" placeholder="Origin..." disabled />
                </div>
              </div>
              <div class="row" style="margin-top:8px">
                <div class="field">
                  <label>PRODUTO (auto)</label>
                  <input id="mProd" class="mono" placeholder="Produto..." disabled />
                </div>
              </div>
            </div>
          </div>

          <div class="step">
            <div class="n">2</div>
            <div style="flex:1">
              <div class="t">Destino</div>
              <div class="row" style="margin-top:8px">
                <div class="row" style="gap:8px;align-items:flex-end">
                  <div class="field" style="flex:1">
                    <label>DESTINATION (location)</label>
                    <input id="mTo" class="mono" inputmode="text" autocapitalize="characters" autocomplete="off" enterkeyhint="done" placeholder="Type or scan destination..." disabled />
                    <div class="hint" id="mToInfo"></div>
                  </div>
                  <button class="btn ghost" id="mToOk" style="min-width:86px;height:46px;margin-top:22px" disabled>OK</button>
                </div>
                <div class="field">
                  <label>STATUS (optional)</label>
                  <select id="mStatus" disabled><option value="" selected>(keep)</option></select>
                </div>
              </div>

              <!-- manter inputs escondidos p/ compatibilidade -->
              <input id="mQtyU" type="number" style="display:none" />
              <input id="mQtyP" type="number" style="display:none" />
              <button id="mAll" style="display:none"></button>
              <button id="mOk" style="display:none"></button>
              <button id="mClear" style="display:none"></button>

              <div class="right" style="margin-top:10px">
                <button class="btn ghost" id="mClear2">Clear</button>
                <button class="btn ok" id="mMove" disabled>Mover</button>
              </div>

              <div id="mMsg"></div>
            </div>
          </div>
        </div>
`;
      setupMove();
    }

    if(state.op==="reabastecer"){
      opView.innerHTML = `
        <div class="card">
          <div class="opTopbar"><button class="opBack" id="opBackBtn">←</button><div style="font-weight:800">Replenish</div></div>
          <h2>Replenish (Pallet → Pallet)</h2>
          <div class="hint">Remove quantidade de uma palete e colocar noutra palete (normalmente para PICKING).</div>

          <div class="step">
            <div class="n">1</div>
            <div style="flex:1">
              <div class="t">Origin</div>
              <div class="row" style="margin-top:8px">
                <div class="field">
                  <label>PALETE ORIGEM (se tiver)</label>
                  <input id="rpPal" class="mono" placeholder="Pica a palete origem..." />
                  <div class="hint" id="rpPalInfo"></div>
                </div>
              </div>

              <div class="row" style="margin-top:6px">
                <label style="display:flex;gap:10px;align-items:center">
                  <input type="checkbox" id="rpManual" />
                  <span>Sem código de palete (usar ORIGEM + PRODUTO)</span>
                </label>
              </div>

              <div id="rpManualBox" style="display:none;margin-top:8px">
                <div class="row">
                  <div class="field">
                    <label>ORIGEM (posição)</label>
                    <input id="rpFrom" class="mono" placeholder="Pica a posição origem..." />
                  </div>
                  <div class="field">
                    <label>PRODUTO</label>
                    <input id="rpProd" class="mono" placeholder="Pica o produto..." disabled />
                  </div>
                </div>
              </div>
            </div>
          </div>

          <div class="step">
            <div class="n">2</div>
            <div style="flex:1">
              <div class="t">Destino</div>
              <div class="row" style="margin-top:8px">
                <div class="field">
                  <label>PALETE DESTINO (opcional)</label>
                  <input id="rpToPal" class="mono" placeholder="Pica palete destino (se já existe)..." disabled />
                  <div class="hint" id="rpToPalInfo"></div>
                </div>
              </div>
              <div class="row" style="margin-top:8px">
                <div class="field">
                  <label>POSIÇÃO DESTINO (picking)</label>
                  <input id="rpTo" class="mono" placeholder="Pica a posição destino..." disabled />
                </div>
              </div>
            </div>
          </div>

          <div class="step">
            <div class="n">3</div>
            <div style="flex:1">
              <div class="t">Quantity</div>
              <div class="row" style="margin-top:8px">
                <div class="field">
                  <label>UNITS</label>
                  <input id="rpQtyU" type="number" min="0" step="1" placeholder="0" disabled />
                </div>
                <div class="field">
                  <label>PALLETS</label>
                  <input id="rpQtyP" type="number" min="0" step="1" placeholder="0" disabled />
                </div>
              </div>
              <div class="row" style="margin-top:8px">
                <div class="field">
                  <label>ORIGIN STATUS (optional)</label>
                  <select id="roStatus" disabled><option value="" selected>(keep)</option></select>
                </div>
              </div>

              <div class="right" style="margin-top:10px">
                <button class="btn ghost" id="rpClear">Clear</button>
                <button class="btn ok" id="rpOk" disabled>Confirm</button>
              </div>

              <div id="rpMsg"></div>
            </div>
          </div>
        </div>
`;
      setupReplenish();
    }

    if(state.op==="eliminar"){
      opView.innerHTML = `
        <div class="card">
          <div class="opTopbar"><button class="opBack" id="opBackBtn">←</button><div style="font-weight:800">Delete pallet</div></div>
          <div class="hint">Apaga a palete do stock (onde estiver). Fica registo em Movements.</div>

          <div class="step">
            <div class="n">1</div>
            <div style="flex:1">
              <div class="t">Pallet</div>
              <div class="row" style="margin-top:8px">
                <div class="field">
                  <label>PALETE</label>
                  <input id="ePal" class="mono" placeholder="Pica a palete..." />
                  <div class="hint" id="eInfo"></div>
                </div>
              </div>
            </div>
          </div>

          <div class="step">
            <div class="n">2</div>
            <div style="flex:1">
              <div class="t">Confirm</div>
              <div class="hint">Vai apagar todas as linhas dessa palete (se existir em mais do que uma posição/produto).</div>

              <div class="right" style="margin-top:10px">
                <button class="btn ghost" id="eClear">Clear</button>
                <button class="btn ok" id="eDel" disabled>Eliminar</button>
              </div>

              <div id="eMsg"></div>
            </div>
          </div>
        </div>
      `;
      setupEliminarPallet();
      return;
    }


  }

  function setupArrumar(){
    async function populateOpStatuses(){
      const statuses = await ensureStatusesLoaded();
      var el = $("aStatus"); if(el){{ el.innerHTML = statusOptions(statuses, true); }}
    }
    populateOpStatuses();

    const opBack = document.getElementById("opBackBtn");
    if(opBack){ opBack.onclick = ()=>{ state.op="menu"; renderOperacao(); }; }
    const aPos=$("aPos"), aProd=$("aProd"), aPal=$("aPal"), aType=$("aType"), aOrigin=$("aOrigin"), aStatus=$("aStatus"), aQtyU=$("aQtyU"), aQtyP=$("aQtyP"), aOk=$("aOk"), aClear=$("aClear"), aGenQty=$("aGenQty"), aGenPal=$("aGenPal"), aPrintPal=$("aPrintPal");
    const aMsg=$("aMsg"), aPosInfo=$("aPosInfo"), aProdInfo=$("aProdInfo");
    let pos=null, prod=null;
    let ORIGINS = [];

    const reset=()=>{
      pos=prod=null; aPos.value=""; aProd.value=""; aPal.value=""; aQtyU.value=""; aQtyP.value="";
      aProd.disabled=true; aPal.disabled=true; aQtyU.disabled=true; aQtyP.disabled=true; aType.disabled=true; aOrigin.disabled=true; aOk.disabled=true;
      aPosInfo.textContent=""; aProdInfo.textContent=""; aMsg.innerHTML="";
      aPos.focus();
    };
    const enable=()=>{
      const u=Math.floor(Number(aQtyU.value||0));
      const p=Math.floor(Number(aQtyP.value||0));
      const origin=(aOrigin && aOrigin.value||"").trim();
      const originOk = !!origin && (!ORIGINS.length || ORIGINS.indexOf(origin) !== -1);
      aOk.disabled=!(pos && prod && (u>0 || p>0) && originOk);
    };

        async function resolvePos(){
try{
        pos = await getPositionByInput(aPos.value);
        if(!pos) throw new Error("Location não encontrada.");
        aPosInfo.textContent = "✅ " + (pos.code||"");
        aProd.disabled=false; aProd.focus(); aMsg.innerHTML="";
      }catch(err){ aMsg.innerHTML=msgBox("Erro: "+esc(err.message), "err"); }
    
    }

    aPos.addEventListener("keydown", (e)=>{ if(e.key==="Enter"){ e.preventDefault(); resolvePos(); }});
    aPos.addEventListener("change", ()=>{ if(aPos.value){ resolvePos(); }});
    aPos.addEventListener("blur", ()=>{ if(aPos.value){ resolvePos(); }});
    const aPosOk=$("aPosOk"); if(aPosOk) aPosOk.addEventListener("click", ()=>resolvePos());
    async function resolveProd(){
      try{
        prod = await getProductByBarcode(aProd.value);
        if(!prod) throw new Error("Produto não encontrado.");
        aProdInfo.textContent = "✅ " + (prod.name||"");
        aPal.disabled=false; aType.disabled=false; aOrigin.disabled=false;
      var _as=$("aStatus"); if(_as) _as.disabled=false; aQtyU.disabled=false; aQtyP.disabled=false;
      aPal.disabled=false;
      if(aGenPal) aGenPal.disabled=false;
      if(aPrintPal) aPrintPal.disabled = !(normalizeBarcode(aPal.value));
        aPal.focus(); aMsg.innerHTML="";
        enable();
      }catch(err){ aMsg.innerHTML=msgBox("Erro: "+esc(err.message), "err"); }
    }

    aProd.addEventListener("keydown", (e)=>{ if(e.key==="Enter"){ e.preventDefault(); resolveProd(); }});
    aProd.addEventListener("change", ()=>{ if(aProd.value){ resolveProd(); }});
    aProd.addEventListener("blur", ()=>{ if(aProd.value){ resolveProd(); }});

    aPal.addEventListener("keydown", (e)=>{ if(e.key==="Enter"){ e.preventDefault(); aQtyU.focus(); }});
    if(aOrigin) aOrigin.addEventListener("change", enable);
    if(aType) aType.addEventListener("change", enable);
    if(aStatus) aStatus.addEventListener("change", enable);
    if(aPal) aPal.addEventListener("input", enable);
    aQtyU.addEventListener("input", enable);
    aQtyP.addEventListener("input", enable);
    aQtyU.addEventListener("keydown",(e)=>{ if(e.key==="Enter"){ e.preventDefault(); aOk.click(); }});
    aQtyP.addEventListener("keydown",(e)=>{ if(e.key==="Enter"){ e.preventDefault(); aOk.click(); }});
        let genPalletCodes = [];
    if(aGenPal){ aGenPal.onclick = ()=>{
      const n = Math.max(1, Math.floor(Number((aGenQty && aGenQty.value) || 1)));
      genPalletCodes = Array.from({length:n}, ()=>generatePalletCode());
      aPal.value = genPalletCodes[0] || "";
      if(aPrintPal) aPrintPal.disabled = !genPalletCodes.length;
      aMsg.innerHTML = msgBox(`✅ Geradas ${n} paletes.`, "ok");
      enable();
    }; }
    if(aPrintPal){ aPrintPal.onclick = ()=>{
      const subtitle = `${aPos.value||""} • ${aProd.value||""}`;
      let codes = (genPalletCodes && genPalletCodes.length) ? genPalletCodes.slice() : [aPal.value];
      codes = codes.map(c=>normalizeBarcode(c)).filter(Boolean);
      if(!codes.length){ aMsg.innerHTML = msgBox("Gera ou pica uma PALETE.", "warn"); return; }
      printPalletLabelsBatch({codes, title:"PALETE", subtitle});
    }; }

aOk.onclick = async ()=>{
      try{
        const qtyU=Math.floor(Number(aQtyU.value||0));
        const qtyP=Math.floor(Number(aQtyP.value||0));
        const origin=(aOrigin.value||"").trim();
        if(!origin || (ORIGINS.length && ORIGINS.indexOf(origin)===-1)){
          throw new Error("Seleciona a ORIGEM (" + (ORIGINS.length ? ORIGINS.join("/") : "configurar no Admin") + ").");
        }
        if(!(pos && prod && (qtyU>0 || qtyP>0))) throw new Error("Falta QTD (UND e/ou Pallets).");
        await addStock(pos.id, prod.id, aPal.value, aType.value, qtyU, qtyP, origin);
        aMsg.innerHTML = msgBox(`✅ OK • ${esc(pos.code)} • ${esc(prod.name)} • ${esc(aType.value)} • ${esc(origin)} • +${qtyU} UND • +${qtyP} Pal`, "ok");
        // manter posição/produto para repetir
        aPal.value=""; aQtyU.value=""; aQtyP.value="";
        aOk.disabled=true;
        aPal.focus();
      }catch(err){ aMsg.innerHTML=msgBox("Erro: "+esc(err.message), "err"); }
    };

    aClear.onclick = reset;
    
    async function populateOrigins(){
      const origins = await ensureOriginsLoaded();
      ORIGINS = (origins||[]).map(x=>String(x||"").trim()).filter(Boolean);
      if(aOrigin){
        aOrigin.innerHTML = ORIGINS.map(o=>`<option value="${esc(o)}">${esc(o)}</option>`).join("");
      }
      enable();
    }

    async function populateStatuses(){
      const statuses = await ensureStatusesLoaded();
      if(aStatus){
        aStatus.innerHTML = statuses.map(s=>`<option value="${esc(s)}">${esc(s)}</option>`).join("");
      }
    }

reset();
    populateOrigins();
    populateStatuses();
  }

  
  async function resolvePalletProduct(positionId, palletBarcode){
    const pbc = normalizeBarcode(palletBarcode);
    if(!positionId || !pbc) return { ok:false, reason:"sem_dados" };

    const qy = query(
      collection(db, COL_STOCK),
      where("positionId", "==", positionId),
      where("palletBarcode", "==", pbc)
    );
    const snap = await getDocs(qy);

    if(snap.empty) return { ok:false, reason:"nao_encontrado", pbc };
    if(snap.size > 1) return { ok:false, reason:"multiplo", pbc, count:snap.size };

    const s = snap.docs[0].data();
    const prodId = s.productId;
    const prodSnap = await getDoc(doc(db, COL_PRODUCTS, prodId));
    const product = prodSnap.exists() ? ({ id:prodId, ...prodSnap.data() }) : ({ id:prodId, name:prodId, barcode:"" });

    return { ok:true, pbc, productId:prodId, product, stock:s };
  }

  async function resolvePalletGlobal(palletBarcode){
    const pbc = normalizeBarcode(palletBarcode);
    if(!pbc) return { ok:false, reason:"sem_dados" };

    const qy = query(
      collection(db, COL_STOCK),
      where("palletBarcode", "==", pbc)
    );
    const snap = await getDocs(qy);

    if(snap.empty) return { ok:false, reason:"nao_encontrado", pbc };

    // Map results with position/product info
    const docs = snap.docs.map(d=>({ id:d.id, ...d.data() }));
    const posIds = [...new Set(docs.map(x=>x.positionId).filter(Boolean))];
    const prodIds = [...new Set(docs.map(x=>x.productId).filter(Boolean))];

    const posSnaps = await Promise.all(posIds.map(id=>getDoc(doc(db, COL_POSITIONS, id))));
    const prodSnaps = await Promise.all(prodIds.map(id=>getDoc(doc(db, COL_PRODUCTS, id))));

    const posMap = new Map(posIds.map((id,i)=>[id, posSnaps[i].exists() ? ({id, ...posSnaps[i].data()}) : ({id, code:id}) ]));
    const prodMap = new Map(prodIds.map((id,i)=>[id, prodSnaps[i].exists() ? ({id, ...prodSnaps[i].data()}) : ({id, name:id, barcode:""}) ]));

    const rows = docs.map(s=>{
      const pos = posMap.get(s.positionId) || {id:s.positionId, code:s.positionId};
      const prod = prodMap.get(s.productId) || {id:s.productId, name:s.productId, barcode:""};
      return { stock:s, position:pos, product:prod };
    });

    // If more than 1, return list to choose
    if(rows.length > 1) return { ok:false, reason:"multiplo", pbc, rows };

    return { ok:true, pbc, ...rows[0] };
  }


function setupRemove(){
    const opBack = document.getElementById("opBackBtn");
    if(opBack){ opBack.onclick = ()=>{ state.op="menu"; renderOperacao(); }; }
    const rPos=$("rPos"), rProd=$("rProd"), rPal=$("rPal"), rQtyU=$("rQtyU"), rQtyP=$("rQtyP");
    const rDo=$("rDo"), rClear2=$("rClear2");
    const rMsg=$("rMsg"), rPalInfo=$("rPalInfo");

    let pos=null, prod=null, pal=null, stock=null;

    function reset(){
      pos=prod=pal=stock=null;
      rPal.value=""; rPos.value=""; rProd.value="";
      rQtyU.value=""; rQtyP.value="";
      rQtyU.disabled=true; rQtyP.disabled=true;
      rDo.disabled=true;
      if(rPalInfo) rPalInfo.textContent="";
      rMsg.innerHTML = msgBox("Pica a PALETE para carregar origem/produto.", "warn");
      rPal.focus();
    }
    reset();
    if(rClear2) rClear2.onclick = reset;

    function enable(){
      const u=Math.floor(Number(rQtyU.value||0));
      const p=Math.floor(Number(rQtyP.value||0));
      rDo.disabled = !(pos && prod && pal && (u>0 || p>0));
    }
    rQtyU.addEventListener("input", enable);
    rQtyP.addEventListener("input", enable);

    async function resolvePal(){
      const code = normalizeBarcode(rPal.value);
      if(!code){ rMsg.innerHTML = msgBox("Pica a PALETE.", "warn"); return; }
      const res = await resolvePalletGlobal(code);
      if(res.ok){
        pal = res.pbc;
        pos = res.position;
        prod = res.product;
        stock = res.stock || {};
        rPos.value = pos.code || "";
        rProd.value = prod.barcode || "";
        rQtyU.disabled=false;
      var _rs=$("rStatus"); if(_rs) _rs.disabled=false; rQtyP.disabled=false;
        rQtyU.focus();
        if(rPalInfo) rPalInfo.innerHTML = `Origin: <b>${esc(pos.code)}</b> • ${esc(prod.name)} • UND ${Number(stock.qtyUnits||0)} • Pal ${Number(stock.qtyPallets||0)}`;
        rMsg.innerHTML = msgBox("Agora indica a quantidade a retirar.", "ok");
        enable();
        return;
      }
      if(res.reason==="multiplo"){
        const rows = res.rows || [];
        rMsg.innerHTML = `
          <div class="msg warn">
            Esta palete aparece em várias linhas. Escolhe:
            <div style="margin-top:8px;display:grid;gap:8px">
              ${rows.map((x,i)=>`
                <button class="btn ghost" data-choice="${i}">
                  ${esc(x.position.code)} • ${esc(x.product.name)} • UND ${Number(x.stock.qtyUnits||0)} • Pal ${Number(x.stock.qtyPallets||0)}
                </button>
              `).join("")}
            </div>
          </div>`;
        rMsg.querySelectorAll("[data-choice]").forEach(btn=>{
          btn.onclick = ()=>{
            const i = Number(btn.getAttribute("data-choice"));
            const pick = rows[i];
            pal = res.pbc;
            pos = pick.position;
            prod = pick.product;
            stock = pick.stock || {};
            rPos.value = pos.code || "";
            rProd.value = prod.barcode || "";
            rQtyU.disabled=false; rQtyP.disabled=false;
            rQtyU.focus();
            if(rPalInfo) rPalInfo.innerHTML = `Origin: <b>${esc(pos.code)}</b> • ${esc(prod.name)}`;
            rMsg.innerHTML = msgBox("Agora indica a quantidade a retirar.", "ok");
            enable();
          };
        });
        return;
      }
      rMsg.innerHTML = msgBox("Pallet não encontrada no stock.", "err");
    }

    rPal.addEventListener("keydown",(e)=>{ if(e.key==="Enter"){ e.preventDefault(); resolvePal(); }});

    rDo.onclick = async ()=>{
      try{
        if(!(pos && prod && pal)) throw new Error("Falta palete.");
        const qtyU=Math.floor(Number(rQtyU.value||0));
        const qtyP=Math.floor(Number(rQtyP.value||0));
        if(!(qtyU>0 || qtyP>0)) throw new Error("Falta QTD.");
        await addStock(pos.id, prod.id, pal, (stock.slotType||"PICKING"), -qtyU, -qtyP);
        rMsg.innerHTML = msgBox(`✅ RETIRADO • ${esc(pos.code)} • ${esc(prod.name)} • ${esc(pal)} • -${qtyU} UND • -${qtyP} Pal`, "ok");
        reset();
      }catch(err){
        rMsg.innerHTML = msgBox("Erro: "+esc(err.message||err), "err");
      }
    };
  }

  function setupReplenish(){
    const opBack = document.getElementById("opBackBtn");
    if(opBack){ opBack.onclick = ()=>{ state.op="menu"; renderOperacao(); }; }
    const rpPal=$("rpPal"), rpManual=$("rpManual"), rpManualBox=$("rpManualBox"),
          rpFrom=$("rpFrom"), rpProd=$("rpProd"),
          rpTo=$("rpTo"), rpToPal=$("rpToPal"),
          rpQtyU=$("rpQtyU"), rpQtyP=$("rpQtyP"),
          rpOk=$("rpOk"), rpClear=$("rpClear");
    const rpMsg=$("rpMsg"), rpPalInfo=$("rpPalInfo"), rpToPalInfo=$("rpToPalInfo");

    let fromPos=null, toPos=null, prod=null;
    let palFrom=null, palTo=null;
    let fromSlotType="COMPLETA";

    function setMsg(text, kind){ rpMsg.innerHTML = msgBox(text, kind||"ok"); }

    function reset(){
      fromPos=toPos=prod=null;
      palFrom=palTo=null;
      fromSlotType="COMPLETA";

      // inputs
      rpPal.value="";
      if(rpFrom) rpFrom.value="";
      if(rpProd) rpProd.value="";
      rpTo.value=""; rpToPal.value="";
      rpQtyU.value=""; rpQtyP.value="";

      // states
      rpPal.disabled = false;
      if(rpManual){ rpManual.checked = false; }
      if(rpManualBox){ rpManualBox.style.display = "none"; }

      if(rpFrom) rpFrom.disabled = false;
      if(rpProd) rpProd.disabled = true;

      rpToPal.disabled = true;
      rpTo.disabled = true;
      rpQtyU.disabled = true;
      rpQtyP.disabled = true;

      rpOk.disabled = true;

      if(rpPalInfo) rpPalInfo.textContent = "";
      if(rpToPalInfo) rpToPalInfo.textContent = "";

      setMsg("Pica a PALETE ORIGEM. Se não tiver código, ativa “Sem código de palete”.", "warn");
      rpPal.focus();
    }

    function enable(){
      const u=Math.floor(Number(rpQtyU.value||0));
      const p=Math.floor(Number(rpQtyP.value||0));
      rpOk.disabled = !(fromPos && toPos && prod && (u>0 || p>0));
    }

    function unlockDestino(){
      rpToPal.disabled = false;
      rpTo.disabled = false;
      // se já veio destino via palete, rpTo pode estar disabled, mas aqui é o modo normal
      if(!rpTo.disabled) rpTo.focus();
    }

    // ===== ORIGEM via PALETE
    async function resolveOriginByPallet(code){
      const res = await resolvePalletGlobal(code);
      if(res.ok){
        palFrom = res.pbc;
        fromPos = res.position;
        prod = res.product;
        fromSlotType = (res.stock && res.stock.slotType) ? res.stock.slotType : "COMPLETA";

        if(rpFrom) rpFrom.value = fromPos.code || "";
        if(rpProd) rpProd.value = prod.barcode || "";

        if(rpFrom) rpFrom.disabled = true;
        if(rpProd) rpProd.disabled = true;

        const s = res.stock || {};
        if(rpPalInfo) rpPalInfo.innerHTML = `Origin: <b>${esc(fromPos.code)}</b> • ${esc(prod.name)} • UND ${Number(s.qtyUnits||0)} • Pal ${Number(s.qtyPallets||0)}`;

        unlockDestino();
        setMsg("Origin OK. Agora (opcional) pica PALETE DESTINO e depois POSIÇÃO DESTINO.", "ok");
        return true;
      }

      if(res.reason==="multiplo"){
        const rows = res.rows || [];
        rpMsg.innerHTML = `
          <div class="msg warn">
            Pallet origem aparece em várias linhas. Escolhe:
            <div style="margin-top:8px;display:grid;gap:8px">
              ${rows.map((x,i)=>`
                <button class="btn ghost" data-choice="${i}">
                  ${esc(x.position.code)} • ${esc(x.product.name)} • UND ${Number(x.stock.qtyUnits||0)} • Pal ${Number(x.stock.qtyPallets||0)}
                </button>
              `).join("")}
            </div>
          </div>`;
        rpMsg.querySelectorAll("[data-choice]").forEach(btn=>{
          btn.onclick = ()=>{
            const i = Number(btn.getAttribute("data-choice"));
            const pick = rows[i];
            palFrom = res.pbc;
            fromPos = pick.position;
            prod = pick.product;
            fromSlotType = (pick.stock && pick.stock.slotType) ? pick.stock.slotType : "COMPLETA";

            if(rpFrom) rpFrom.value = fromPos.code || "";
            if(rpProd) rpProd.value = prod.barcode || "";

            if(rpFrom) rpFrom.disabled = true;
            if(rpProd) rpProd.disabled = true;

            if(rpPalInfo) rpPalInfo.innerHTML = `Origin: <b>${esc(fromPos.code)}</b> • ${esc(prod.name)}`;
            unlockDestino();
            setMsg("Origin OK. Agora (opcional) pica PALETE DESTINO e depois POSIÇÃO DESTINO.", "ok");
          };
        });
        return false;
      }

      setMsg("Pallet origem não encontrada. Se não tiver código, ativa “Sem código de palete”.", "err");
      return false;
    }

    // ===== DESTINO via PALETE (opcional): se existir, valida produto e pode auto-definir posição
    async function handleDestinoPallet(code){
      const res = await resolvePalletGlobal(code);
      if(res.ok){
        if(res.product && res.product.id && prod && res.product.id !== prod.id){
          setMsg("A palete destino é de outro produto. Usa uma palete destino do mesmo produto.", "err");
          palTo = null;
          if(rpToPalInfo) rpToPalInfo.textContent = "";
          return;
        }
        palTo = res.pbc;
        toPos = res.position;

        rpTo.value = toPos.code || "";
        rpTo.disabled = true;

        const s = res.stock || {};
        if(rpToPalInfo) rpToPalInfo.innerHTML = `Destino: <b>${esc(toPos.code)}</b> • UND ${Number(s.qtyUnits||0)} • Pal ${Number(s.qtyPallets||0)}`;

        rpQtyU.disabled = false;
        rpQtyP.disabled = false;
        rpQtyU.focus();
        enable();
        setMsg("Destino OK. Agora indica quantidades.", "ok");
        return;
      }

      // não encontrada: aceita como "vai criar/atualizar" mas precisa posição
      palTo = code;
      if(rpToPalInfo) rpToPalInfo.textContent = "Não existe no stock (vai ser criada/atualizada no destino).";
      rpTo.disabled = false;
      rpTo.focus();
      setMsg("Agora pica a POSIÇÃO DESTINO.", "warn");
    }

    // ===== eventos
    rpClear.onclick = reset;

    rpQtyU.addEventListener("input", enable);
    rpQtyP.addEventListener("input", enable);

    // toggle manual
    if(rpManual){
      rpManual.onchange = ()=>{
        const on = !!rpManual.checked;
        if(rpManualBox) rpManualBox.style.display = on ? "" : "none";
        if(on){
          // manual: limpa palete e desbloqueia campos
          palFrom = null;
          fromPos = null;
          prod = null;
          rpPal.value = "";
          if(rpPalInfo) rpPalInfo.textContent = "";
          if(rpFrom) { rpFrom.disabled = false; rpFrom.value = ""; rpFrom.focus(); }
          if(rpProd) { rpProd.disabled = true; rpProd.value = ""; }
          // bloquear destino até ter produto
          rpToPal.disabled = true;
          rpTo.disabled = true;
          rpQtyU.disabled = true;
          rpQtyP.disabled = true;
          rpOk.disabled = true;
          setMsg("Modo manual: ORIGEM → PRODUTO.", "warn");
        }else{
          reset();
        }
      };
    }

    // palete origem enter
    rpPal.addEventListener("keydown", async (e)=>{
      if(e.key!=="Enter") return;
      e.preventDefault();
      if(rpManual && rpManual.checked) return;
      const code = normalizeBarcode(rpPal.value);
      if(!code){ setMsg("Pica a palete origem.", "warn"); return; }
      await resolveOriginByPallet(code);
    });

    // manual origin
    if(rpFrom){
      rpFrom.addEventListener("keydown", async (e)=>{
        if(e.key!=="Enter") return;
        e.preventDefault();
        if(!(rpManual && rpManual.checked)) return;
        const code = normalizeBarcode(rpFrom.value);
        const p = await getPositionByCode(code);
        if(!p){ setMsg("Origin não encontrada.", "err"); return; }
        fromPos = p;
        if(rpProd){ rpProd.disabled = false; rpProd.focus(); }
        setMsg("Origin OK. Agora pica o produto.", "ok");
      });
    }

    if(rpProd){
      rpProd.addEventListener("keydown", async (e)=>{
        if(e.key!=="Enter") return;
        e.preventDefault();
        if(!(rpManual && rpManual.checked)) return;
        if(!fromPos){ setMsg("Primeiro pica a origem.", "warn"); return; }
        const bc = normalizeBarcode(rpProd.value);
        const p = await getProductByBarcode(bc);
        if(!p){ setMsg("Produto não encontrado.", "err"); return; }
        prod = p;
        fromSlotType = "COMPLETA";
        unlockDestino();
        setMsg("Produto OK. Agora (opcional) palete destino e posição destino.", "ok");
      });
    }

    // destino palete optional
    rpToPal.addEventListener("keydown", async (e)=>{
      if(e.key!=="Enter") return;
      e.preventDefault();
      if(!prod){ setMsg("Primeiro define a origem.", "warn"); return; }
      const code = normalizeBarcode(rpToPal.value);
      if(!code){
        palTo = null;
        if(rpToPalInfo) rpToPalInfo.textContent = "";
        rpTo.disabled = false;
        rpTo.focus();
        setMsg("Pica a posição destino.", "warn");
        return;
      }
      await handleDestinoPallet(code);
    });

    // destino posição
    rpTo.addEventListener("keydown", async (e)=>{
      if(e.key!=="Enter") return;
      e.preventDefault();
      if(!prod){ setMsg("Primeiro define a origem.", "warn"); return; }
      if(rpTo.disabled) return; // já definido via palete destino
      const code = normalizeBarcode(rpTo.value);
      const p = await getPositionByCode(code);
      if(!p){ setMsg("Destino não encontrado.", "err"); return; }
      toPos = p;
      rpQtyU.disabled = false;
      rpQtyP.disabled = false;
      rpQtyU.focus();
      setMsg("Destino OK. Agora indica quantidades.", "ok");
      enable();
    });

    // confirmar
    rpOk.onclick = async ()=>{
      try{
        if(!(fromPos && toPos && prod)) throw new Error("Falta origem/destino/produto.");
        const qtyU=Math.floor(Number(rpQtyU.value||0));
        const qtyP=Math.floor(Number(rpQtyP.value||0));
        if(!(qtyU>0 || qtyP>0)) throw new Error("Falta quantidade.");

        const srcPallet = palFrom ? palFrom : (rpPal.value || "");
        const dstPallet = palTo ? palTo : (rpToPal.value || "");

        await transferReplenish(fromPos.id, toPos.id, prod.id, srcPallet, dstPallet, qtyU, qtyP);

        setMsg(`✅ Reabastecido • ${esc(fromPos.code)} → ${esc(toPos.code)} • ${esc(prod.name)} • ${qtyU} UND • ${qtyP} Pal`, "ok");
        rpQtyU.value=""; rpQtyP.value="";
        rpQtyU.focus();
        enable();
      }catch(err){
        setMsg("Erro: "+esc(err.message||err), "err");
      }
    };

    reset();
  }

  async function loadPositionById(id){
    const snap = await getDoc(doc(db, COL_POSITIONS, id));
    return snap.exists() ? ({ id: snap.id, ...snap.data() }) : null;
  }
  async function loadProductById(id){
    const snap = await getDoc(doc(db, COL_PRODUCTS, id));
    return snap.exists() ? ({ id: snap.id, ...snap.data() }) : null;
  }

  async function listStockByPallet(palletBarcode){
    const pbc = normalizeBarcode(palletBarcode);
    if(!pbc) return [];
    const qy = query(collection(db, COL_STOCK), where("palletBarcode","==",pbc), limit(200));
    const snap = await getDocs(qy);
    const rows = [];
    snap.forEach(d=> rows.push({ id:d.id, ...d.data() }));
    return rows;
  }

  async function deletePalletEverywhere(palletBarcode){
    const user = auth.currentUser;
    if(!user) throw new Error("Not signed in.");
    if(!canOperate(user)) throw new Error("No permission.");

    const pbc = normalizeBarcode(palletBarcode);
    if(!pbc) throw new Error("Pallet inválida.");

    const rows = await listStockByPallet(pbc);
    if(rows.length===0) throw new Error("Esta palete não existe no stock.");

    // batch delete + log movements
    let batch = writeBatch(db);
    let ops = 0;

    for(const r of rows){
      const ref = doc(db, COL_STOCK, r.id);
      batch.delete(ref);
      const mvRef = doc(collection(db, COL_MOVEMENTS));
      batch.set(mvRef, {
        type: "ELIMINAR_PALETE",
        ts: serverTimestamp(),
        userId: user.uid,
        userEmail: (user.email||""),
        userLabel: ((user.email||"").split("@")[0]||""),
        userEmail: (user.email||""),
        userLabel: ((user.email||"").split("@")[0]||""),
        positionId: r.positionId || "",
        productId: r.productId || "",
        palletBarcode: pbc,
        slotType: r.slotType || "",
        qtyUnits: Number(r.qtyUnits||0),
        qtyPallets: Number(r.qtyPallets||0),
        origin: r.origin || "",
      });
      ops += 2;

      if(ops >= 400){
        await batch.commit();
        batch = writeBatch(db);
        ops = 0;
      }
    }
    if(ops>0) await batch.commit();
    return rows.length;
  }

  function setupEliminarPallet(){
    const ePal=$("ePal"), eInfo=$("eInfo"), eClear=$("eClear"), eDel=$("eDel"), eMsg=$("eMsg");
    const opBack = document.getElementById("opBackBtn");
    if(opBack){ opBack.onclick = ()=>{ state.op="menu"; renderOperacao(); }; }

    let pallet=null, rows=[];

    function reset(){
      pallet=null; rows=[];
      ePal.value="";
      if(eInfo) eInfo.textContent="";
      eDel.disabled=true;
      eMsg.innerHTML = msgBox("Pica a PALETE.", "warn");
      ePal.focus();
    }
    reset();
    eClear.onclick = reset;

    async function refreshInfo(){
      if(!pallet){ eDel.disabled=true; return; }
      rows = await listStockByPallet(pallet);
      if(rows.length===0){
        if(eInfo) eInfo.textContent="Não encontrada no stock.";
        eDel.disabled=true;
        eMsg.innerHTML = msgBox("Pallet não existe no stock.", "err");
        return;
      }
      // Build simple list
      const lines = [];
      for(const r of rows.slice(0,12)){
        const pos = await loadPositionById(r.positionId||"");
        const prod = await loadProductById(r.productId||"");
        lines.push(`${(pos.code||r.positionId||"-")} • ${(prod.name||prod.barcode||r.productId||"-")} • UND ${Number(r.qtyUnits||0)} • Pal ${Number(r.qtyPallets||0)} • ${r.slotType||""}`);
      }
      if(rows.length>12) lines.push(`… +${rows.length-12} linhas`);
      if(eInfo) eInfo.textContent = `${rows.length} linha(s) encontradas`;
      eMsg.innerHTML = `<div class="msg warn"><b>${esc(pallet)}</b><div style="margin-top:8px;white-space:pre-line">${esc(lines.join("\n"))}</div></div>`;
      eDel.disabled=false;
    }

    ePal.addEventListener("keydown", async (e)=>{
      if(e.key!=="Enter") return;
      e.preventDefault();
      const code = normalizeBarcode(ePal.value);
      if(!code){ eMsg.innerHTML = msgBox("Pica a palete.", "warn"); return; }
      pallet = code;
      await refreshInfo();
    });

    eDel.onclick = async ()=>{
      try{
        if(!pallet) throw new Error("Falta palete.");
        eDel.disabled=true;
        const n = await deletePalletEverywhere(pallet);
        eMsg.innerHTML = msgBox(`✅ Eliminada palete ${esc(pallet)} (${n} linha(s)).`, "ok");
        if(window.matchMedia("(max-width: 820px)").matches){ state.op="menu"; renderOperacao(); }
        else reset();
      }catch(err){
        eDel.disabled=false;
        eMsg.innerHTML = msgBox("Erro: "+esc(err.message||err), "err");
      }
    };
  }



  function setupMove(){
    const opBack = document.getElementById("opBackBtn");
    if(opBack){ opBack.onclick = ()=>{ state.op="menu"; renderOperacao(); }; }
    const mFrom=$("mFrom"), mTo=$("mTo"), mProd=$("mProd"), mPal=$("mPal");
    const mMove=$("mMove"), mClear2=$("mClear2");
    const mMsg=$("mMsg");
    const mQtyU=$("mQtyU"), mQtyP=$("mQtyP");
    const mStatus=$("mStatus");

    let fromPos=null, toPos=null, prod=null, pal=null, stock=null;

    function reset(){
      fromPos=toPos=prod=pal=stock=null;
      mPal.value=""; mFrom.value=""; mProd.value=""; mTo.value="";
      mTo.disabled = true;
      if(mStatus){ mStatus.disabled = true; mStatus.innerHTML = '<option value="" selected>(keep)</option>'; }
      mMove.disabled = true;
      mMsg.innerHTML = msgBox("Pica a PALETE para carregar origem/produto.", "warn");
      mPal.focus();
    }
    reset();
    if(mClear2) mClear2.onclick = reset;

    async function resolvePal(){
      const code = normalizeBarcode(mPal.value);
      if(!code){ mMsg.innerHTML = msgBox("Pica a PALETE.", "warn"); return; }
      const res = await resolvePalletGlobal(code);
      if(res.ok){
        pal = res.pbc;
        fromPos = res.position;
        prod = res.product;
        stock = res.stock || {};
        mFrom.value = fromPos.code || "";
        mProd.value = prod.barcode || "";
        mTo.disabled = false;
        mTo.focus();
        if(mStatus){
          mStatus.disabled = false;
          // carregar lista de statuses do Admin
          ensureStatusesLoaded().then(list=>{
            const arr = (list && list.length) ? list : DEFAULT_STATUSES;
            mStatus.innerHTML = '<option value="" selected>(keep)</option>' + arr.map(s=>`<option value="${esc(s)}">${esc(s)}</option>`).join('');
          }).catch(()=>{
            const arr = DEFAULT_STATUSES;
            mStatus.innerHTML = '<option value="" selected>(keep)</option>' + arr.map(s=>`<option value="${esc(s)}">${esc(s)}</option>`).join('');
          });
        }
        mMsg.innerHTML = msgBox(`Pallet OK • Origin <b>${esc(fromPos.code)}</b> • ${esc(prod.name)} • UND ${Number(stock.qtyUnits||0)} • Pal ${Number(stock.qtyPallets||0)}`, "ok");
        return;
      }
      if(res.reason==="multiplo"){
        const rows = res.rows || [];
        mMsg.innerHTML = `
          <div class="msg warn">
            Esta palete aparece em várias linhas. Escolhe:
            <div style="margin-top:8px;display:grid;gap:8px">
              ${rows.map((x,i)=>`
                <button class="btn ghost" data-choice="${i}">
                  ${esc(x.position.code)} • ${esc(x.product.name)} • UND ${Number(x.stock.qtyUnits||0)} • Pal ${Number(x.stock.qtyPallets||0)}
                </button>
              `).join("")}
            </div>
          </div>`;
        mMsg.querySelectorAll("[data-choice]").forEach(btn=>{
          btn.onclick = ()=>{
            const i = Number(btn.getAttribute("data-choice"));
            const pick = rows[i];
            pal = res.pbc;
            fromPos = pick.position;
            prod = pick.product;
            stock = pick.stock || {};
            mFrom.value = fromPos.code || "";
            mProd.value = prod.barcode || "";
            mTo.disabled = false;
            mTo.focus();
            if(mStatus){
              mStatus.disabled = false;
              ensureStatusesLoaded().then(list=>{
                const arr = (list && list.length) ? list : DEFAULT_STATUSES;
                mStatus.innerHTML = '<option value="" selected>(keep)</option>' + arr.map(s=>`<option value="${esc(s)}">${esc(s)}</option>`).join('');
              }).catch(()=>{
                const arr = DEFAULT_STATUSES;
                mStatus.innerHTML = '<option value="" selected>(keep)</option>' + arr.map(s=>`<option value="${esc(s)}">${esc(s)}</option>`).join('');
              });
            }
            mMsg.innerHTML = msgBox(`Pallet OK • Origin <b>${esc(fromPos.code)}</b> • ${esc(prod.name)}`, "ok");
          };
        });
        return;
      }
      mMsg.innerHTML = msgBox("Pallet não encontrada no stock.", "err");
    }

    mPal.addEventListener("keydown", (e)=>{ if(e.key==="Enter"){ e.preventDefault(); resolvePal(); }});

        async function resolveDest(){
if(!(fromPos && prod && pal)){ mMsg.innerHTML = msgBox("Primeiro pica a PALETE.", "warn"); return; }
      const code = normalizeBarcode(mTo.value);
      const p = await getPositionByCode(code);
      if(!p){ mMsg.innerHTML = msgBox("Destino não encontrado.", "err"); return; }
      toPos = p;
      mMove.disabled = false;
      mMsg.innerHTML = msgBox(`Destino OK: <b>${esc(toPos.code)}</b>. Agora podes mover.`, "ok");
    
    }

    mTo.addEventListener("keydown", (e)=>{ if(e.key==="Enter"){ e.preventDefault(); resolveDest(); }});
    const mToOk=$("mToOk"); if(mToOk) mToOk.addEventListener("click", ()=>resolveDest());
mMove.onclick = async ()=>{
      try{
        if(!(fromPos && toPos && prod && pal)) throw new Error("Falta dados.");
        const u = Number(stock.qtyUnits||0);
        const p = Number(stock.qtyPallets||0);
        if(!(u>0 || p>0)) throw new Error("Sem stock na palete.");
        if(mQtyU) mQtyU.value = String(u);
        if(mQtyP) mQtyP.value = String(p);
        const st = (mStatus && mStatus.value) ? mStatus.value : "";
        await moveStock(fromPos.id, toPos.id, prod.id, pal, u, p, st);
        mMsg.innerHTML = msgBox(`✅ MOVIDO • ${esc(fromPos.code)} → ${esc(toPos.code)} • ${esc(prod.name)} • ${esc(pal)}`, "ok");
        reset();
      }catch(err){
        mMsg.innerHTML = msgBox("Erro: "+esc(err.message||err), "err");
      }
    };
  }

  // ===== Lookup (PC e Mobile) =====
  function renderLookup(){
    viewEl.innerHTML = `
      <div class="card">
        <h2 style="margin:0 0 8px">Lookup</h2>
        <div class="hint">Ver onde estão <b>paletes/produtos</b> (por produto) e o que existe numa <b>posição</b> (por posição).</div>
        <div class="row" style="margin-top:10px">
          <button class="btn ghost" id="btnExportStock">Export Stock (CSV ;)</button>
          <button class="btn ghost" id="btnExportMov" style="display:none">Export Movements (CSV ;)</button>
          <div class="hint" id="exportHint" style="margin-left:6px"></div>
        </div>
      </div>

      <div class="grid two" style="margin-top:12px">
        <div class="card">
          <h2>Por Produto</h2>
          <div class="hint">Pica o NOME/SKU do produto para ver as posições e as paletes (agrupa barcodes).</div>
          <div class="row" style="margin-top:10px">
            <div class="field">
              <label>PRODUTO (nome/SKU)</label>
              <input id="cpProd" class="mono" placeholder="Picar produto..." />
              <div class="hint" id="cpProdInfo"></div>
            </div>
            <div class="right">
              <button class="btn ok" id="cpGo">Procurar</button>
              <button class="btn ghost" id="cpClear">Clear</button>
            </div>
          </div>
          <div id="cpMsg"></div>
          <div class="divider"></div>
          <div id="cpResults"></div>
        </div>

        <div class="card">
          <h2>Por Location</h2>
          <div class="hint">Pica o barcode da posição para ver produtos/paletes arrumados.</div>
          <div class="row" style="margin-top:10px">
            <div class="field">
              <label>POSIÇÃO (barcode)</label>
              <input id="csPos" class="mono" placeholder="Picar posição..." />
              <div class="hint" id="csPosInfo"></div>
            </div>
            <div class="right">
              <button class="btn ok" id="csGo">Procurar</button>
              <button class="btn ghost" id="csClear">Clear</button>
            </div>
          </div>
          <div id="csMsg"></div>
          <div class="divider"></div>
          <div id="csResults"></div>
        </div>
      </div>
    `;
    setupLookupProduto();
    setupLookupPosicao();
    setupTotaisProduto();

    const btnS = $("btnExportStock");
    const btnM = $("btnExportMov");
    const hint = $("exportHint");
    if(btnM) btnM.style.display = canAdmin(auth.currentUser) ? "" : "none";

    if(btnS) btnS.onclick = async ()=>{
      try{ hint.textContent = "A exportar stock..."; await exportStockCSV(); hint.textContent = "✅ Stock exportado."; }
      catch(e){ hint.textContent = "❌ " + (e.message||e); }
    };
    if(btnM) btnM.onclick = async ()=>{
      try{ hint.textContent = "A exportar movimentos..."; await exportMovementsCSV(); hint.textContent = "✅ Movements exportados."; }
      catch(e){ hint.textContent = "❌ " + (e.message||e); }
    };
  }

  async function computeStockTotalsByProduct(){
    const snap = await getDocs(query(collection(db, COL_STOCK), limit(2000)));
    const map = new Map(); // productId -> {completeU,completeP,pickingU,pickingP, palletsComplete:Set, palletsPicking:Set}
    snap.forEach(d=>{
      const x = d.data() || {};
      const pid = x.productId || "";
      if(!pid) return;
      const slot = String(x.slotType||"PICKING").toUpperCase();
      const u = Number(x.qtyUnits||0);
      const p = Number(x.qtyPallets||0);
      const pal = normalizeBarcode(x.palletBarcode||"");
      if(!map.has(pid)){
        map.set(pid, { completeU:0, completeP:0, pickingU:0, pickingP:0, palletsComplete:new Set(), palletsPicking:new Set() });
      }
      const t = map.get(pid);
      if(slot==="COMPLETA"){
        t.completeU += u;
        t.completeP += p;
        if(pal) t.palletsComplete.add(pal);
      }else{
        t.pickingU += u;
        t.pickingP += p;
        if(pal) t.palletsPicking.add(pal);
      }
    });

    // load products to map barcode/name
    const prodSnap = await getDocs(query(collection(db, COL_PRODUCTS), limit(3000)));
    const prodMap = new Map();
    prodSnap.forEach(d=> prodMap.set(d.id, ({ id:d.id, ...d.data() })));

    const rows = [];
    map.forEach((t, pid)=>{
      const pr = prodMap.get(pid) || { name:"", barcode:"" };
      rows.push({
        productId: pid,
        name: pr.name || "",
        barcode: pr.barcode || "",
        UND_COMPLETA: t.completeU,
        PAL_COMPLETA: t.completeP,
        N_PALETES_COMPLETA: t.palletsComplete.size,
        UND_PICKING: t.pickingU,
        PAL_PICKING: t.pickingP,
        N_PALETES_PICKING: t.palletsPicking.size
      });
    });

    rows.sort((a,b)=> (a.name||"").localeCompare(b.name||"") || (a.barcode||"").localeCompare(b.barcode||""));
    return rows;
  }

  function toCSVSemicolon(rows){
    const headers = ["produto","barcode","UND_COMPLETA","PAL_COMPLETA","N_PALETES_COMPLETA","UND_PICKING","PAL_PICKING","N_PALETES_PICKING"];
    const lines = [headers.join(";")];
    for(const r of rows){
      const vals = [
        (r.name||"").replace(/;/g,","),
        (r.barcode||""),
        r.UND_COMPLETA||0, r.PAL_COMPLETA||0, r.N_PALETES_COMPLETA||0,
        r.UND_PICKING||0, r.PAL_PICKING||0, r.N_PALETES_PICKING||0
      ];
      lines.push(vals.join(";"));
    }
    return lines.join("\n");
  }

  function downloadText(filename, text){
    const blob = new Blob([text], {type:"text/plain;charset=utf-8"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url; a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(()=>URL.revokeObjectURL(url), 4000);
  }

  async function renderStock(){
    viewEl.innerHTML = `
      <div class="card">
        <h2 style="margin:0 0 6px">Stock by product</h2>
        <div class="hint">Totais separados por <b>COMPLETA</b> e <b>PICKING</b>.</div>

        <div class="row" style="margin-top:10px;gap:10px;flex-wrap:wrap">
          <div class="pill" id="stTotals" style="padding:10px 12px;border:1px solid var(--stroke);border-radius:999px;background:var(--surface2)">A calcular totais…</div>
        </div>

        <div class="row" style="margin-top:10px;align-items:flex-end">
          <div class="field" style="flex:1;min-width:200px">
            <label>Search</label>
            <input id="stQ" placeholder="nome ou barcode..." />
          </div>
          <button class="btn ghost" id="stReload">Refresh</button>
          <button class="btn ok" id="stExport">Export ;</button>
        </div>

        <div id="stMsg"></div>
        <div style="overflow:auto;margin-top:12px">
          <table class="tbl">
            <thead>
              <tr>
                <th>Produto</th><th>Barcode</th>
                <th>UND (Completa)</th><th>Pal (Completa)</th><th>#Pallets</th>
                <th>UND (Picking)</th><th>Pal (Picking)</th><th>#Pallets</th>
              </tr>
            </thead>
            <tbody id="stBody"></tbody>
          </table>
        </div>
      </div>
    `;

    const stQ=$("stQ"), stReload=$("stReload"), stExport=$("stExport"), stBody=$("stBody"), stMsg=$("stMsg"), stTotals=$("stTotals");
    let all = [];
    async function load(){
      stMsg.innerHTML = msgBox("A carregar…", "warn");
      all = await computeStockTotalsByProduct();
      // Totais gerais no separador Stock
      try{
        if(stTotals){
          const g = await computeGlobalTotals();
          stTotals.innerHTML = `<b>Total Paletes:</b> ${Number(g.totalPallets||0)} &nbsp; · &nbsp; <b>Total UND:</b> ${Number(g.totalUnits||0)} &nbsp; · &nbsp; <b>Total Produtos:</b> ${Number(all.length||0)}`;
        }
      }catch(e){
        if(stTotals) stTotals.innerHTML = `<span class="err">❌ Totais: ${esc(e.message||e)}</span>`;
      }
      stMsg.innerHTML = msgBox(`✅ ${all.length} produto(s).`, "ok");
      draw();
    }
    function draw(){
      const q = (stQ.value||"").toLowerCase().trim();
      const rows = q ? all.filter(r => (r.name||"").toLowerCase().includes(q) || (r.barcode||"").toLowerCase().includes(q)) : all;
      stBody.innerHTML = rows.map(r=>`
        <tr>
          <td>${esc(r.name)}</td>
          <td class="mono">${esc(r.barcode)}</td>
          <td class="mono">${Number(r.UND_COMPLETA||0)}</td>
          <td class="mono">${Number(r.PAL_COMPLETA||0)}</td>
          <td class="mono">${Number(r.N_PALETES_COMPLETA||0)}</td>
          <td class="mono">${Number(r.UND_PICKING||0)}</td>
          <td class="mono">${Number(r.PAL_PICKING||0)}</td>
          <td class="mono">${Number(r.N_PALETES_PICKING||0)}</td>
        </tr>
      `).join("");
    }
    stQ.addEventListener("input", draw);
    stReload.onclick = load;
    stExport.onclick = ()=>{
      const csv = toCSVSemicolon(all);
      const stamp = new Date().toISOString().slice(0,19).replace(/[:T]/g,"-");
      downloadText(`stock_por_produto_${stamp}.csv`, csv);
    };
    await load();
  }


  function setupLookupProduto(){
    const inp = $("cpProd"), go = $("cpGo"), clear = $("cpClear");
    const msg = $("cpMsg"), info = $("cpProdInfo"), results = $("cpResults");
    let chosen = null; // {name, barcodes[]}

    const reset=()=>{ chosen=null; inp.value=""; info.textContent=""; msg.innerHTML=""; results.innerHTML=""; inp.focus(); };

    // Carrega todos os produtos e agrupa por nome, juntando vários barcodes ao mesmo produto
    async function getProductsGrouped(){
      const snap = await getDocs(collection(db, COL_PRODUCTS));
      const map = new Map(); // nameLower -> {name, barcodes:[], anyDoc:{}}
      snap.forEach(d=>{
        const p = d.data()||{};
        const name = String(p.name||"").trim();
        if(!name) return;
        const key = name.toLowerCase();
        const ent = map.get(key) || { name, barcodes:[], any:p };
        ent.barcodes.push(d.id);
        // mantém campos úteis do "any" se existirem
        ent.any = ent.any || p;
        map.set(key, ent);
      });
      return Array.from(map.values()).sort((a,b)=>a.name.localeCompare(b.name,"pt",{sensitivity:"base"}));
    }

    async function pickByText(txt){
      const q = String(txt||"").trim().toLowerCase();
      if(!q) return null;

      const list = await getProductsGrouped();
      // prioridade: match exato pelo nome
      let hits = list.filter(p=>p.name.toLowerCase()===q);
      // senão: contém
      if(hits.length===0) hits = list.filter(p=>p.name.toLowerCase().includes(q));
      if(hits.length===0){
        // fallback: se o user colar um barcode, tentar encontrar por barcode (id do doc)
        const snap = await getDoc(doc(db, COL_PRODUCTS, encodeKey(normalizeBarcode(q))));
        if(snap.exists()){
          const p = snap.data()||{};
          const name = String(p.name||"").trim();
          if(name) return { name, barcodes:[snap.id], any:p };
        }
        return null;
      }
      if(hits.length===1) return hits[0];

      // demasiados resultados → mostrar lista para escolher
      results.innerHTML = `
        <div class="hint">Foram encontrados <b>${hits.length}</b> produtos. Refina a pesquisa ou escolhe um:</div>
        <div style="overflow:auto;margin-top:8px">
          <table>
            <thead><tr><th>Produto</th><th>#Barcodes</th><th></th></tr></thead>
            <tbody>
              ${hits.slice(0,50).map((p,i)=>`
                <tr>
                  <td>${esc(p.name)}</td>
                  <td><b>${p.barcodes.length}</b></td>
                  <td><button class="btn ok" data-pick="${i}">Usar</button></td>
                </tr>
              `).join("")}
            </tbody>
          </table>
        </div>
        ${hits.length>50?`<div class="hint">A mostrar os primeiros 50. Refina a pesquisa para ver menos.</div>`:""}
      `;
      results.querySelectorAll("[data-pick]").forEach(btn=>{
        btn.onclick = async ()=>{
          const idx = Number(btn.getAttribute("data-pick"));
          const p = hits.slice(0,50)[idx];
          if(!p) return;
          inp.value = p.name;
          await run(p);
        };
      });
      return "__PICKING__";
    }

    async function queryStockForBarcodes(barcodes){
      const chunks = [];
      const maxIn = 30; // limite do Firestore para "in"
      for(let i=0;i<barcodes.length;i+=maxIn){
        chunks.push(barcodes.slice(i,i+maxIn));
      }
      const all = [];
      for(const ch of chunks){
        const qy = query(collection(db, COL_STOCK), where("productId","in", ch));
        const snap = await getDocs(qy);
        snap.forEach(d=>all.push(d.data()));
      }
      return all;
    }

    async function run(preset=null){
      try{
        msg.innerHTML=""; results.innerHTML="";
        const sel = preset || await pickByText(inp.value);
        if(sel==="__PICKING__") return;
        if(!sel) throw new Error("Produto não encontrado (por nome/SKU).");
        chosen = sel;
        info.textContent = "✅ " + (chosen.name||"");

        const rowsAll = await queryStockForBarcodes(chosen.barcodes||[]);
        const rows = rowsAll.filter(x=>(Number(x.qtyUnits||0)>0 || Number(x.qtyPallets||0)>0));
        if(rows.length===0){ results.innerHTML = msgBox("Sem stock em posições.", "warn"); return; }

        // carregar códigos das posições
        const posSnaps = await Promise.all(rows.map(r=>getDoc(doc(db, COL_POSITIONS, r.positionId))));
        const view = rows.map((r,i)=>{
          const ps = posSnaps[i];
          const posCode = ps.exists() ? (ps.data().code || r.positionId) : r.positionId;
          return {
            posCode,
            palletBarcode: r.palletBarcode || "",
            slotType: r.slotType || "PICKING",
            qtyUnits: Number(r.qtyUnits||0),
            qtyPallets: Number(r.qtyPallets||0),
            status: r.status || ""
          };
        }).sort((a,b)=>(a.posCode||"").localeCompare(b.posCode||"", "pt", {sensitivity:"base"}));

        results.innerHTML = `
          <div style="overflow:auto">
            <table>
              <thead><tr><th>Location</th><th>Pallet</th><th>Status</th><th>Tipo</th><th>UND</th><th>Pal</th></tr></thead>
              <tbody>
                ${view.map(v=>`
                  <tr>
                    <td><span class="mono">${esc(v.posCode)}</span></td>
                    <td><span class="mono">${esc(v.palletBarcode || "—")}</span></td>
                    <td>${esc(v.status || "—")}</td>
                    <td>${esc(v.slotType)}</td>
                    <td><b>${v.qtyUnits}</b></td><td><b>${v.qtyPallets}</b></td>
                  </tr>
                `).join("")}
              </tbody>
            </table>
          </div>
        `;
      }catch(err){ msg.innerHTML = msgBox("Erro: "+esc(err.message||err), "err"); }
    }

    inp.addEventListener("keydown",(e)=>{ if(e.key==="Enter"){ e.preventDefault(); run(); }});
    go.onclick = ()=>run();
    clear.onclick = reset;
    reset();
  }

  function setupLookupPosicao(){
    const inp = $("csPos"), go = $("csGo"), clear = $("csClear");
    const msg = $("csMsg"), info = $("csPosInfo"), results = $("csResults");
    let pos = null;

    const reset=()=>{ pos=null; inp.value=""; info.textContent=""; msg.innerHTML=""; results.innerHTML=""; inp.focus(); };

    async function run(){
      try{
        msg.innerHTML=""; results.innerHTML="";
        pos = await getPositionByInput(inp.value);
        if(!pos) throw new Error("Location não encontrada.");
        info.textContent = "✅ " + (pos.code||"");

        const qy = query(collection(db, COL_STOCK), where("positionId","==", pos.id));
        const snap = await getDocs(qy);
        if(snap.empty){ results.innerHTML = msgBox("Sem stock nesta posição.", "warn"); return; }

        const rows = snap.docs.map(d=>d.data()).filter(x=>(Number(x.qtyUnits||0)>0 || Number(x.qtyPallets||0)>0));

        // carregar nomes dos produtos
        const prodSnaps = await Promise.all(rows.map(r=>getDoc(doc(db, COL_PRODUCTS, r.productId))));
        const view = rows.map((r,i)=>{
          const ps = prodSnaps[i];
          const prodName = ps.exists() ? (ps.data().name || r.productId) : r.productId;
          return {
            prodName,
            palletBarcode: r.palletBarcode || "",
            slotType: r.slotType || "PICKING",
            qtyUnits: Number(r.qtyUnits||0),
            qtyPallets: Number(r.qtyPallets||0),
            status: r.status || ""
          };
        }).sort((a,b)=>(a.prodName||"").localeCompare(b.prodName||"", "pt", {sensitivity:"base"}));

        results.innerHTML = `
          <div style="overflow:auto">
            <table>
              <thead><tr><th>Produto</th><th>Pallet</th><th>Status</th><th>Tipo</th><th>UND</th><th>Pal</th></tr></thead>
              <tbody>
                ${view.map(v=>`
                  <tr>
                    <td>${esc(v.prodName)}</td>
                    <td><span class="mono">${esc(v.palletBarcode || "—")}</span></td>
                    <td>${esc(v.status || "—")}</td>
                    <td>${esc(v.slotType)}</td>
                    <td><b>${v.qtyUnits}</b></td><td><b>${v.qtyPallets}</b></td>
                  </tr>
                `).join("")}
              </tbody>
            </table>
          </div>
        `;
      }catch(err){ msg.innerHTML = msgBox("Erro: "+esc(err.message), "err"); }
    }

    inp.addEventListener("keydown",(e)=>{ if(e.key==="Enter"){ e.preventDefault(); run(); }});
    go.onclick = run;
    clear.onclick = reset;
    reset();
  }

  function setupTotaisProduto(){
    const tbl = $("totTable");
    const filt = $("totFilter");
    const btn = $("btnExportTotals");
    if(!tbl || !filt || !btn) return;

    let cache = [];

    async function load(){
      tbl.innerHTML = `<tr><td colspan="4">A carregar...</td></tr>`;
      cache = await computeTotalsByProduct();
      render();
    }
    function render(){
      const term = (filt.value||"").toLowerCase().trim();
      const rows = cache.filter(r=>{
        if(!term) return true;
        const hay = `${r.name} ${r.barcode}`.toLowerCase();
        return hay.includes(term);
      });
      tbl.innerHTML = rows.map(r=>`
        <tr>
          <td>${esc(r.name)}</td>
          <td><span class="mono">${esc(r.barcode || "—")}</span></td>
          <td><b>${Number(r.qtyUnits||0)}</b></td>
          <td><b>${Number(r.qtyPallets||0)}</b></td>
        </tr>
      `).join("") || `<tr><td colspan="4">Sem resultados.</td></tr>`;
    }

    filt.oninput = render;
    btn.onclick = async ()=>{ await exportTotalsCSV(); };

    load();
  }


  
  // ===== Export CSV (separador ;) =====
  function downloadTextFile(filename, text){
    const blob = new Blob([text], {type:"text/csv;charset=utf-8"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  }
  function sanitizeBarcodeExport(v){
    const s = (v ?? "").toString().trim();
    // remover prefixos comuns indesejados (ex.: `123, '123)
    return s.replace(/^([`']+)\s*/, "");
  }

  function csvEscape(v){
    const s = (v ?? "").toString();
    if(/[;\n"]/g.test(s)) return '"' + s.replace(/"/g,'""') + '"';
    return s;
  }

  
  async function exportProductsCSV(){
    const snap = await getDocs(collection(db, COL_PRODUCTS));
    const rows = snap.docs.map(d=>({id:d.id, ...d.data()}))
      .sort((a,b)=>(a.name||"").localeCompare(b.name||"", "pt", {sensitivity:"base"}));

    const header = ["produto","barcode"].join(";");
    const lines = rows.map(r=>[
      csvEscape(r.name || ""),
      csvEscape(sanitizeBarcodeExport(r.barcode || ""))
    ].join(";"));

    downloadTextFile(`produtos_${new Date().toISOString().slice(0,10)}.csv`, [header, ...lines].join("\n"));
  }

async function exportStockCSV(){
    const snap = await getDocs(collection(db, COL_STOCK));
    const rows = snap.docs.map(d=>({id:d.id, ...d.data()}));

    const posIds = [...new Set(rows.map(r=>r.positionId).filter(Boolean))];
    const prodIds = [...new Set(rows.map(r=>r.productId).filter(Boolean))];

    const posSnaps = await Promise.all(posIds.map(id=>getDoc(doc(db, COL_POSITIONS, id))));
    const prodSnaps = await Promise.all(prodIds.map(id=>getDoc(doc(db, COL_PRODUCTS, id))));

    const posMap = new Map(posIds.map((id,i)=>[id, posSnaps[i].exists() ? (posSnaps[i].data().code || id) : id]));
    const prodMap = new Map(prodIds.map((id,i)=>[id, prodSnaps[i].exists() ? (prodSnaps[i].data().name || id) : id]));

    const header = ["posicao","produto","palletBarcode","tipo","status","origem","qtyUnits","qtyPallets","updatedAt"].join(";");
    const lines = rows.map(r=>{
      const code = posMap.get(r.positionId) || r.positionId || "";
      const name = prodMap.get(r.productId) || r.productId || "";
      const upd = r.updatedAt.toDate ? r.updatedAt.toDate().toISOString() : "";
      return [
        csvEscape(code),
        csvEscape(name),
        csvEscape(r.palletBarcode || ""),
        csvEscape(r.slotType || ""),
        csvEscape(r.origin || ""),
        csvEscape(Number(r.qtyUnits||0)),
        csvEscape(Number(r.qtyPallets||0)),
        csvEscape(upd),
      ].join(";");
    });

    downloadTextFile(`stock_${new Date().toISOString().slice(0,10)}.csv`, [header, ...lines].join("\n"));
  }

  async function exportMovementsCSV(){
    const u = auth.currentUser;
    const snap = await getDocs(collection(db, COL_MOVEMENTS));
    const rows = snap.docs.map(d=>({id:d.id, ...d.data()}));

    const header = ["ts","type","userId","positionId","fromPositionId","toPositionId","productId","palletBarcode","slotType","qtyUnits","qtyPallets"].join(";");
    const lines = rows
      .sort((a,b)=>{
        const ta = a.ts.toDate ? a.ts.toDate().getTime() : 0;
        const tb = b.ts.toDate ? b.ts.toDate().getTime() : 0;
        return tb - ta;
      })
      .map(r=>{
        const ts = r.ts.toDate ? r.ts.toDate().toISOString() : "";
        return [
          csvEscape(ts),
          csvEscape(r.type || ""),
          csvEscape(r.userId || ""),
          csvEscape(r.positionId || ""),
          csvEscape(r.fromPositionId || ""),
          csvEscape(r.toPositionId || ""),
          csvEscape(r.productId || ""),
          csvEscape(r.palletBarcode || ""),
          csvEscape(r.slotType || ""),
          csvEscape(Number(r.qtyUnits||0)),
          csvEscape(Number(r.qtyPallets||0)),
        ].join(";");
      });

    downloadTextFile(`movimentos_${new Date().toISOString().slice(0,10)}.csv`, [header, ...lines].join("\n"));
  }

  async function computeTotalsByProduct(){
    const prodSnap = await getDocs(collection(db, COL_PRODUCTS));
    const products = prodSnap.docs.map(d=>({id:d.id, ...d.data()}));
    const prodMap = new Map(products.map(p=>[p.id, p]));

    const stockSnap = await getDocs(collection(db, COL_STOCK));
    const stock = stockSnap.docs.map(d=>d.data());

    const agg = new Map();
    for(const s of stock){
      const pid = s.productId;
      if(!pid) continue;
      const u = Number(s.qtyUnits||0);
      const p = Number(s.qtyPallets||0);
      if(!agg.has(pid)) agg.set(pid, {u:0,p:0});
      const a = agg.get(pid);
      a.u += u; a.p += p;
    }

    const rows = [];
    for(const [pid, a] of agg.entries()){
      const pr = prodMap.get(pid) || {name:pid, barcode:""};
      rows.push({ productId:pid, name:pr.name||pid, barcode:pr.barcode||"", qtyUnits:a.u, qtyPallets:a.p });
    }
    rows.sort((x,y)=>(x.name||"").localeCompare(y.name||"", "pt", {sensitivity:"base"}));
    return rows;
  }

  async function computeGlobalTotals(){
    const stockSnap = await getDocs(collection(db, COL_STOCK));
    let totalUnits = 0;
    let totalPallets = 0;
    stockSnap.forEach(d=>{
      const x = d.data() || {};
      totalUnits += Number(x.qtyUnits||0);
      totalPallets += Number(x.qtyPallets||0);
    });
    return { totalUnits, totalPallets, rows: stockSnap.size };
  }



  async function exportTotalsCSV(){
    const rows = await computeTotalsByProduct();
    const header = ["produto","barcode","qtyUnitsTotal","qtyPalletsTotal"].join(";");
    const lines = rows.map(r=>[
      csvEscape(r.name||""),
      csvEscape(sanitizeBarcodeExport(r.barcode||"")),
      csvEscape(Number(r.qtyUnits||0)),
      csvEscape(Number(r.qtyPallets||0))
    ].join(";"));
    downloadTextFile(`totais_produto_${new Date().toISOString().slice(0,10)}.csv`, [header, ...lines].join("\\n"));
  }



  // ===== Movements: listar + anular/editar =====
  function renderMovements(){
    const u = auth.currentUser;
    viewEl.innerHTML = `
      <div class="card">
        <h2 style="margin:0 0 8px">Movements</h2>
        <div class="hint">Listagem e correções. Para manter histórico, o sistema faz <b>anulação</b> (reverte stock) e <b>edição</b> (ajusta stock pela diferença).</div>
        <div class="row" style="margin-top:10px">
          <div class="field">
            <label>Mostrar</label>
            <select id="mvLimit">
              <option value="50">50</option>
              <option value="100" selected>100</option>
              <option value="200">200</option>
            </select>
          </div>
          <div class="field">
            <label>Filtro (texto)</label>
            <input id="mvFilter" placeholder="posição / produto / palete / tipo / user" />
          </div>
          <div class="right">
            <button class="btn ghost" id="mvReload">Refresh</button>
            <button class="btn ghost" id="mvExport">Export Movements (CSV ;)</button>
          </div>
        </div>
        <div id="mvMsg"></div>
      </div>

      <div class="card" style="margin-top:12px">
        <h2 style="margin:0 0 8px">Totais gerais</h2>
        <div class="hint">Total de paletes registadas no sistema (soma de <code>qtyPallets</code> em todos os registos de stock). UND é a soma de <code>qtyUnits</code>.</div>
        <div class="row" style="margin-top:10px">
          <div id="grandTotals" class="hint">A carregar...</div>
          <div class="right"><button class="btn ghost" id="grandReload">Refresh</button></div>
        </div>
      </div>

      <div class="card" style="margin-top:12px">
        <h2 style="margin:0 0 8px">Total por Produto</h2>
        <div class="hint">Soma de UND e Pallets em todas as posições/paletes.</div>
        <div class="row" style="margin-top:10px">
          <div class="field"><label>Filtro produto</label><input id="totFilter" placeholder="nome ou barcode" /></div>
          <div class="right"><button class="btn ghost" id="btnExportTotals">Export Totais (CSV ;)</button></div>
        </div>
        <div style="overflow:auto;margin-top:10px">
          <table>
            <thead><tr><th>Produto</th><th>Barcode</th><th>UND Total</th><th>Pallets Total</th></tr></thead>
            <tbody id="totTable"></tbody>
          </table>
        </div>
      </div>

<div class="card" style="margin-top:12px;overflow:auto">
        <table>
          <thead>
            <tr>
              <th>Data</th><th>Tipo</th><th>Location</th><th>Origin</th><th>Destino</th>
              <th>Produto</th><th>Pallet</th><th>Tipo Slot</th><th>UND</th><th>Pal</th><th>User</th><th></th>
            </tr>
          </thead>
          <tbody id="mvTable"></tbody>
        </table>
      </div>

      <div id="mvModal" style="display:none;position:fixed;inset:0;background:rgba(0,0,0,.55);padding:14px;z-index:999">
        <div class="card" style="max-width:720px;margin:0 auto">
          <h2 style="margin:0 0 8px">Editar Movimento</h2>
          <div class="hint">Só é suportado editar/anular: <b>ARRUMAR</b>, <b>RETIRAR</b>, <b>MUDAR</b>. “MUDAR_TUDO” fica bloqueado.</div>
          <div class="divider"></div>
          <div class="grid two">
            <div class="card" style="padding:12px">
              <div class="hint">Campos editáveis</div>
              <div class="row" style="margin-top:10px">
                <div class="field"><label>UND</label><input id="mvEditU" type="number" min="0" step="1" /></div>
                <div class="field"><label>Pallets</label><input id="mvEditP" type="number" min="0" step="1" /></div>
              </div>
              <div class="row">
                <div class="field"><label>Tipo Slot (ARRUMAR/RETIRAR)</label>
                  <select id="mvEditSlot">
                    <option value="">(manter)</option>
                    <option value="PICKING">PICKING</option>
                    <option value="COMPLETA">COMPLETA</option>
                  </select>
                </div>
              </div>
              <div class="hint">Para MUDAR, a edição ajusta quantidades do movimento (reverte diferença entre origem/destino).</div>
            </div>

            <div class="card" style="padding:12px">
              <div class="hint">Motivo (obrigatório)</div>
              <div class="row" style="margin-top:10px">
                <div class="field"><label>Motivo</label><input id="mvReason" placeholder="Ex.: engano no scanner" /></div>
              </div>
              <div id="mvEditMsg"></div>
              <div class="right" style="margin-top:10px">
                <button class="btn danger" id="mvCancelBtn">Anular (reverter stock)</button>
                <button class="btn ok" id="mvSaveBtn">Guardar edição</button>
                <button class="btn ghost" id="mvCloseBtn">Fechar</button>
              </div>
            </div>
          </div>
        </div>
      </div>
    `;

    setupMovements();
  }

  async function setupMovements(){
    const mvTable = $("mvTable");
    const mvMsg = $("mvMsg");
    const mvReload = $("mvReload");
    const mvLimit = $("mvLimit");
    const mvFilter = $("mvFilter");
    const mvExport = $("mvExport");

    const grandTotals = $("grandTotals");
    const grandReload = $("grandReload");

    const modal = $("mvModal");
    const editU = $("mvEditU");
    const editP = $("mvEditP");
    const editSlot = $("mvEditSlot");
    const reason = $("mvReason");
    const editMsg = $("mvEditMsg");
    const btnSave = $("mvSaveBtn");
    const btnCancel = $("mvCancelBtn");
    const btnClose = $("mvCloseBtn");

    let current = null;

    function openModal(mv){
      current = mv;
      editMsg.innerHTML = "";
      reason.value = "";
      editU.value = Number(mv.qtyUnits||0);
      editP.value = Number(mv.qtyPallets||0);
      editSlot.value = ""; // manter por defeito
      // bloquear MUDAR_TUDO e outros
      const allowed = ["ARRUMAR","RETIRAR","MUDAR"].includes((mv.type||"").toUpperCase()) && !mv.cancelled;
      btnSave.disabled = !allowed;
      btnCancel.disabled = !allowed;
      modal.style.display = "block";
    }
    function closeModal(){
      modal.style.display = "none";
      current = null;
    }

    btnClose.onclick = closeModal;
    modal.addEventListener("click", (e)=>{ if(e.target === modal) closeModal(); });

    
    async function loadGrandTotals(){
      try{
        if(!grandTotals) return;
        grandTotals.textContent = "A carregar...";
        const g = await computeGlobalTotals();
        grandTotals.innerHTML = `<b>Total Paletes:</b> ${Number(g.totalPallets||0)} &nbsp; · &nbsp; <b>Total UND:</b> ${Number(g.totalUnits||0)} &nbsp; · &nbsp; <span class="muted">${Number(g.rows||0)} registos</span>`;
      }catch(e){
        if(grandTotals) grandTotals.innerHTML = `<span class="err">❌ ${esc(e.message||e)}</span>`;
      }
    }

async function load(){
      mvMsg.innerHTML = "";
      mvTable.innerHTML = `<tr><td colspan="12">A carregar...</td></tr>`;
      await loadGrandTotals();
      const n = Number(mvLimit.value||100);

      // Movements precisam de leitura para operadores também (ver rules abaixo)
      const qy = query(collection(db, COL_MOVEMENTS), orderBy("ts","desc"), limit(n));
      const snap = await getDocs(qy);

      const rows = snap.docs.map(d=>({id:d.id, ...d.data()}));
      const term = (mvFilter.value||"").toLowerCase().trim();

      // Map ids -> nomes/códigos (best effort)
      const posIds = [...new Set(rows.flatMap(r=>[r.positionId,r.fromPositionId,r.toPositionId]).filter(Boolean))];
      const prodIds = [...new Set(rows.map(r=>r.productId).filter(Boolean))];

      const posSnaps = await Promise.all(posIds.map(id=>getDoc(doc(db, COL_POSITIONS, id))));
      const prodSnaps = await Promise.all(prodIds.map(id=>getDoc(doc(db, COL_PRODUCTS, id))));

      const posMap = new Map(posIds.map((id,i)=>[id, posSnaps[i].exists() ? (posSnaps[i].data().code || id) : id]));
      // Prod info: name + barcode (for search by barcode/SKU)
      const prodInfoMap = new Map(prodIds.map((id,i)=>{
        if(!prodSnaps[i].exists()) return [id, { name:id, barcode:"" }];
        const d = prodSnaps[i].data() || {};
        return [id, { name:(d.name||id), barcode:(d.barcode||"") }];
      }));
      const prodMap = new Map(prodIds.map(id=>[id, (prodInfoMap.get(id)?.name || id)]));

      const view = rows.map(r=>{
        const ts = r.ts.toDate ? r.ts.toDate().toLocaleString() : "";
        const type = (r.type||"");
        const pos = posMap.get(r.positionId) || "";
        const from = posMap.get(r.fromPositionId) || "";
        const to = posMap.get(r.toPositionId) || "";
        const prod = prodMap.get(r.productId) || "";
        const prodBarcode = (r.productId ? (prodInfoMap.get(r.productId)?.barcode || "") : "");
        const prodNameInline = (r.productName || r.product || r.productLabel || "");
        const pal = r.palletBarcode || "";
        const slot = r.slotType || "";
        const u = Number(r.qtyUnits||0);
        const p = Number(r.qtyPallets||0);
        const user = (r.userEmail || r.userLabel || r.userId || "");
        const cancelled = !!r.cancelled;

        const hay = `${ts} ${type} ${pos} ${from} ${to} ${prod} ${prodNameInline} ${prodBarcode} ${pal} ${slot} ${u} ${p} ${user}`.toLowerCase();
        if(term && !hay.includes(term)) return null;

        return { ...r, _ts: ts, _type:type, _pos:pos, _from:from, _to:to, _prod:prod, _pal:pal, _slot:slot, _u:u, _p:p, _user:user, _cancelled:cancelled };
      }).filter(Boolean);

      mvTable.innerHTML = view.map(r=>`
        <tr style="${r._cancelled ? "opacity:.55" : ""}">
          <td>${esc(r._ts)}${r._cancelled ? "<div class='hint'>ANULADO</div>" : ""}</td>
          <td>${esc(r._type)}</td>
          <td><span class="mono">${esc(r._pos)}</span></td>
          <td><span class="mono">${esc(r._from)}</span></td>
          <td><span class="mono">${esc(r._to)}</span></td>
          <td>${esc(r._prod)}</td>
          <td><span class="mono">${esc(r._pal || "—")}</span></td>
          <td>${esc(r._slot || "—")}</td>
          <td><b>${r._u}</b></td>
          <td><b>${r._p}</b></td>
          <td><span class="mono">${esc(r._user)}</span></td>
          <td style="white-space:nowrap">
            <button class="btn ghost" data-act="edit" data-id="${r.id}">Editar/Anular</button>
          </td>
        </tr>
      `).join("") || `<tr><td colspan="12">Sem resultados.</td></tr>`;

      mvTable.querySelectorAll("button[data-act='edit']").forEach(b=>{
        b.onclick = ()=>{
          const id = b.dataset.id;
          const mv = view.find(x=>x.id===id);
          if(mv) openModal(mv);
        };
      });
    }

    mvReload.onclick = load;
    if(grandReload) grandReload.onclick = loadGrandTotals;
    mvLimit.onchange = load;
    mvFilter.oninput = load;

    mvExport.onclick = async ()=>{
      try{
        mvMsg.innerHTML = msgBox("A exportar movimentos...", "");
        await exportMovementsCSV(); // já existe helper
        mvMsg.innerHTML = msgBox("✅ Movements exportados.", "ok");
      }catch(e){
        mvMsg.innerHTML = msgBox("❌ " + esc(e.message||e), "err");
      }
    };

    btnCancel.onclick = async ()=>{
      try{
        if(!current) return;
        const mv = current;
        if(mv.cancelled) throw new Error("Já está anulado.");
        const why = (reason.value||"").trim();
        if(!why) throw new Error("Motivo obrigatório.");

        await cancelMovement(mv.id, why);
        editMsg.innerHTML = msgBox("✅ Movimento anulado (stock revertido).", "ok");
        setupTotaisProduto();
    await load();
      }catch(e){
        editMsg.innerHTML = msgBox("❌ " + esc(e.message||e), "err");
      }
    };

    btnSave.onclick = async ()=>{
      try{
        if(!current) return;
        const mv = current;
        if(mv.cancelled) throw new Error("Já está anulado.");
        const why = (reason.value||"").trim();
        if(!why) throw new Error("Motivo obrigatório.");

        const newU = Math.floor(Number(editU.value||0));
        const newP = Math.floor(Number(editP.value||0));
        if(newU<0 || newP<0) throw new Error("Quantitys inválidas.");
        if(newU===0 && newP===0) throw new Error("Indica UND e/ou Pallets.");

        const newSlot = editSlot.value || null;

        await editMovement(mv.id, { qtyUnits:newU, qtyPallets:newP, slotType:newSlot }, why);
        editMsg.innerHTML = msgBox("✅ Movimento editado (stock ajustado).", "ok");
        await load();
      }catch(e){
        editMsg.innerHTML = msgBox("❌ " + esc(e.message||e), "err");
      }
    };

    await load();
  }

  async function cancelMovement(mvId, reason){
    const user = auth.currentUser;
    if(!user) throw new Error("Not signed in.");
    if(!canOperate(user)) throw new Error("No permission.");

    const mvRef = doc(db, COL_MOVEMENTS, mvId);

    await runTransaction(db, async (tx)=>{
      const mvSnap = await tx.get(mvRef);
      if(!mvSnap.exists()) throw new Error("Movimento não existe.");
      const mv = mvSnap.data();
      if(mv.cancelled) throw new Error("Já anulado.");
      const type = (mv.type||"").toUpperCase();
      if(!["ARRUMAR","RETIRAR","MUDAR"].includes(type)) throw new Error("Não suportado para anular.");

      // marcar movimento como anulado (preserva histórico)
      tx.set(mvRef, { cancelled:true, cancelledAt:serverTimestamp(), cancelledBy:user.uid, cancelReason:reason }, {merge:true});

      // reverter stock
      if(type==="ARRUMAR"){
        const pos = mv.positionId, prod = mv.productId, pal = mv.palletBarcode||"", slot = mv.slotType||"PICKING";
        const u = Number(mv.qtyUnits||0), p = Number(mv.qtyPallets||0);
        const stockRef = doc(db, COL_STOCK, stockKey(pos, prod, palletIdFromBarcode(pal)));
        const snap = await tx.get(stockRef);
        const curU = snap.exists()? Number(snap.data().qtyUnits||0):0;
        const curP = snap.exists()? Number(snap.data().qtyPallets||0):0;
        const nextU = curU - u;
        const nextP = curP - p;
        if(nextU < 0 || nextP < 0) throw new Error("Não dá para anular: stock insuficiente.");
        if(nextU===0 && nextP===0) tx.delete(stockRef);
        else tx.set(stockRef, { qtyUnits:nextU, qtyPallets:nextP, updatedAt:serverTimestamp() }, {merge:true});
      }else if(type==="RETIRAR"){
        const pos = mv.positionId, prod = mv.productId, pal = mv.palletBarcode||"", slot = mv.slotType||"PICKING";
        const u = Number(mv.qtyUnits||0), p = Number(mv.qtyPallets||0);
        const stockRef = doc(db, COL_STOCK, stockKey(pos, prod, palletIdFromBarcode(pal)));
        const snap = await tx.get(stockRef);
        const curU = snap.exists()? Number(snap.data().qtyUnits||0):0;
        const curP = snap.exists()? Number(snap.data().qtyPallets||0):0;
        const nextU = curU + u;
        const nextP = curP + p;
        tx.set(stockRef, { positionId:pos, productId:prod, palletBarcode:normalizeBarcode(pal), slotType:slot, qtyUnits:nextU, qtyPallets:nextP, updatedAt:serverTimestamp() }, {merge:true});
      }else if(type==="MUDAR"){
        const from = mv.fromPositionId, to = mv.toPositionId, prod = mv.productId, pal = mv.palletBarcode||"";
        const u = Number(mv.qtyUnits||0), p = Number(mv.qtyPallets||0);
        const palId = palletIdFromBarcode(pal);
        const fromRef = doc(db, COL_STOCK, stockKey(from, prod, palId));
        const toRef = doc(db, COL_STOCK, stockKey(to, prod, palId));

        const toSnap = await tx.get(toRef);
        const toU = toSnap.exists()? Number(toSnap.data().qtyUnits||0):0;
        const toP = toSnap.exists()? Number(toSnap.data().qtyPallets||0):0;
        const toType = toSnap.exists()? (toSnap.data().slotType||"PICKING") : "PICKING";
        if(toU < u || toP < p) throw new Error("Não dá para anular: destino sem stock suficiente.");
        const nextToU = toU - u;
        const nextToP = toP - p;
        if(nextToU===0 && nextToP===0) tx.delete(toRef);
        else tx.set(toRef, { qtyUnits:nextToU, qtyPallets:nextToP, updatedAt:serverTimestamp() }, {merge:true});

        const fromSnap = await tx.get(fromRef);
        const fromU = fromSnap.exists()? Number(fromSnap.data().qtyUnits||0):0;
        const fromP = fromSnap.exists()? Number(fromSnap.data().qtyPallets||0):0;
        const fromType = fromSnap.exists()? (fromSnap.data().slotType||toType) : toType;

        tx.set(fromRef, { positionId:from, productId:prod, palletBarcode:normalizeBarcode(pal), slotType:fromType, qtyUnits:fromU + u, qtyPallets:fromP + p, updatedAt:serverTimestamp() }, {merge:true});
      }

      // registar ação (opcional) como novo movimento do tipo "ANULACAO"
      const mv2Ref = doc(collection(db, COL_MOVEMENTS));
      tx.set(mv2Ref, { type:"ANULACAO", ts:serverTimestamp(), userId:user.uid, refMovementId:mvId, reason }, {merge:true});
    });
  }

  async function editMovement(mvId, patch, reason){
    const user = auth.currentUser;
    if(!user) throw new Error("Not signed in.");
    if(!canOperate(user)) throw new Error("No permission.");

    const mvRef = doc(db, COL_MOVEMENTS, mvId);

    await runTransaction(db, async (tx)=>{
      const mvSnap = await tx.get(mvRef);
      if(!mvSnap.exists()) throw new Error("Movimento não existe.");
      const mv = mvSnap.data();
      if(mv.cancelled) throw new Error("Já anulado.");
      const type = (mv.type||"").toUpperCase();
      if(!["ARRUMAR","RETIRAR","MUDAR"].includes(type)) throw new Error("Não suportado para editar.");

      const oldU = Number(mv.qtyUnits||0), oldP = Number(mv.qtyPallets||0);
      const newU = Number(patch.qtyUnits||0), newP = Number(patch.qtyPallets||0);
      const dU = newU - oldU;
      const dP = newP - oldP;

      // atualizar movimento (guardar snapshot anterior)
      tx.set(mvRef, {
        edited:true,
        editedAt:serverTimestamp(),
        editedBy:user.uid,
        editReason:reason,
        prev: { qtyUnits:oldU, qtyPallets:oldP, slotType: mv.slotType || "" },
        qtyUnits:newU,
        qtyPallets:newP,
        ...(patch.slotType ? { slotType: patch.slotType } : {})
      }, {merge:true});

      // ajustar stock pela diferença
      if(type==="ARRUMAR"){
        const pos = mv.positionId, prod = mv.productId, pal = mv.palletBarcode||"";
        const slot = patch.slotType ? patch.slotType : (mv.slotType||"PICKING");
        const stockRef = doc(db, COL_STOCK, stockKey(pos, prod, palletIdFromBarcode(pal)));
        const snap = await tx.get(stockRef);
        const curU = snap.exists()? Number(snap.data().qtyUnits||0):0;
        const curP = snap.exists()? Number(snap.data().qtyPallets||0):0;
        const nextU = curU + dU;
        const nextP = curP + dP;
        if(nextU < 0 || nextP < 0) throw new Error("Edição inválida: stock ficaria negativo.");
        if(nextU===0 && nextP===0) tx.delete(stockRef);
        else tx.set(stockRef, { positionId:pos, productId:prod, palletBarcode:normalizeBarcode(pal), slotType:slot, qtyUnits:nextU, qtyPallets:nextP, updatedAt:serverTimestamp() }, {merge:true});
      }else if(type==="RETIRAR"){
        // retirar: movimento representa saída; stock foi diminuído por old; ajustar por -d (se d é +, retira mais)
        const pos = mv.positionId, prod = mv.productId, pal = mv.palletBarcode||"";
        const slot = patch.slotType ? patch.slotType : (mv.slotType||"PICKING");
        const stockRef = doc(db, COL_STOCK, stockKey(pos, prod, palletIdFromBarcode(pal)));
        const snap = await tx.get(stockRef);
        const curU = snap.exists()? Number(snap.data().qtyUnits||0):0;
        const curP = snap.exists()? Number(snap.data().qtyPallets||0):0;
        const nextU = curU - dU;
        const nextP = curP - dP;
        if(nextU < 0 || nextP < 0) throw new Error("Edição inválida: stock insuficiente.");
        if(nextU===0 && nextP===0) tx.delete(stockRef);
        else tx.set(stockRef, { qtyUnits:nextU, qtyPallets:nextP, updatedAt:serverTimestamp(), slotType:slot }, {merge:true});
      }else if(type==="MUDAR"){
        const from = mv.fromPositionId, to = mv.toPositionId, prod = mv.productId, pal = mv.palletBarcode||"";
        const palId = palletIdFromBarcode(pal);

        const fromRef = doc(db, COL_STOCK, stockKey(from, prod, palId));
        const toRef = doc(db, COL_STOCK, stockKey(to, prod, palId));

        // mudança: aplicar diferença em ambos (se new > old, tirar mais de origem e pôr mais em destino)
        const fromSnap = await tx.get(fromRef);
        const fromU = fromSnap.exists()? Number(fromSnap.data().qtyUnits||0):0;
        const fromP = fromSnap.exists()? Number(fromSnap.data().qtyPallets||0):0;
        /* handled by nextFrom<0 check */
        const nextFromU = fromU - dU;
        const nextFromP = fromP - dP;
        if(nextFromU < 0 || nextFromP < 0) throw new Error("Edição inválida: origem sem stock.");
        if(nextFromU===0 && nextFromP===0) tx.delete(fromRef);
        else tx.set(fromRef, { qtyUnits:nextFromU, qtyPallets:nextFromP, updatedAt:serverTimestamp() }, {merge:true});

        const toSnap = await tx.get(toRef);
        const toU = toSnap.exists()? Number(toSnap.data().qtyUnits||0):0;
        const toP = toSnap.exists()? Number(toSnap.data().qtyPallets||0):0;
        const nextToU = toU + dU;
        const nextToP = toP + dP;
        if(nextToU < 0 || nextToP < 0) throw new Error("Edição inválida: destino ficaria negativo.");
        if(nextToU===0 && nextToP===0) tx.delete(toRef);
        else tx.set(toRef, { positionId:to, productId:prod, palletBarcode:normalizeBarcode(pal), qtyUnits:nextToU, qtyPallets:nextToP, updatedAt:serverTimestamp() }, {merge:true});
      }

      // registar ação
      const mv2Ref = doc(collection(db, COL_MOVEMENTS));
      tx.set(mv2Ref, { type:"EDICAO", ts:serverTimestamp(), userId:user.uid, refMovementId:mvId, reason, qtyUnits:newU, qtyPallets:newP }, {merge:true});
    });
  }


  // ===== Pallets: Gerador de códigos de barras =====
  function generatePalletCode(prefix){
    const p = (prefix||"PLT").trim().toUpperCase().replace(/[^A-Z0-9_-]/g,"") || "PLT";
    const d = new Date();
    const y = d.getFullYear().toString();
    const m = String(d.getMonth()+1).padStart(2,"0");
    const day = String(d.getDate()).padStart(2,"0");
    const hh = String(d.getHours()).padStart(2,"0");
    const mm = String(d.getMinutes()).padStart(2,"0");
    const ss = String(d.getSeconds()).padStart(2,"0");
    const rand = String(Math.floor(Math.random()*100000)).padStart(5,"0");
    return `${p}-${y}${m}${day}-${hh}${mm}${ss}-${rand}`;
  }

  function renderBarcode(svgEl, code){
    if(!svgEl) return;
    if(typeof JsBarcode === "undefined"){
      svgEl.outerHTML = `<div class="msg err">JsBarcode não carregou. Confirma internet/CDN.</div>`;
      return;
    }
    try{
      JsBarcode(svgEl, code, {
        format: "CODE128",
        lineColor: "#101624",
        width: 2,
        height: 70,
        displayValue: true,
        fontSize: 14,
        margin: 8
      });
    }catch(e){
      svgEl.outerHTML = `<div class="msg err">Erro a gerar barcode: ${esc(e.message||e)}</div>`;
    }
  }

  function printPalletLabel({code, title, subtitle}){
    const w = window.open("", "_blank");
    const safeTitle = esc(title||"PALETE");
    const safeSubtitle = esc(subtitle||"");
    const safeCode = esc(code||"");
    w.document.write(`<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>Etiqueta Pallet</title>
<style>
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;margin:18px}
  .box{border:1px solid #111;padding:14px;border-radius:14px;max-width:520px}
  h1{font-size:18px;margin:0 0 6px}
  .sub{color:#333;margin:0 0 10px}
  .code{font-family:ui-monospace,Menlo,Consolas,monospace;margin-top:8px}
  @media print { button{display:none} body{margin:0} .box{border:none} }
</style>
<script src="https://cdn.jsdelivr.net/npm/jsbarcode@3.11.6/dist/JsBarcode.all.min.js"><\/script>
</head>
<body>
  <button onclick="window.print()">Imprimir</button>
  <div class="box">
    <h1>${safeTitle}</h1>
    <div class="sub">${safeSubtitle}</div>
    <svg id="b"></svg>
    <div class="code">${safeCode}</div>
  </div>
<script>
  JsBarcode("#b", "${safeCode}", {format:"CODE128", lineColor:"#111", width:2, height:80, displayValue:true, fontSize:14, margin:10});
<\/script>
</body>
</html>`);
    w.document.close();
  }

  // Imprime várias etiquetas (1 por folha)
  function printPalletLabelsBatch({codes, title, subtitle}){
    const safeTitle = esc(title||"PALETE");
    const safeSubtitle = esc(subtitle||"");
    const list = (codes||[]).map(c=>String(c||"")).filter(Boolean);
    if(!list.length){
      sgBox("Nada para imprimir.", "warn");
      return;
    }

    // Use an iframe for reliable printing (avoids blank popups on some browsers)
    let frame = document.getElementById("printFrame");
    if(!frame){
      frame = document.createElement("iframe");
      frame.id = "printFrame";
      frame.style.position = "fixed";
      frame.style.right = "0";
      frame.style.bottom = "0";
      frame.style.width = "0";
      frame.style.height = "0";
      frame.style.border = "0";
      frame.style.opacity = "0";
      document.body.appendChild(frame);
    }

    const pages = list.map((c,i)=>`<div class="page">
      <div class="box">
        <h1>${safeTitle}</h1>
        <div class="sub">${safeSubtitle}</div>
        <svg id="b${i}"></svg>
        <div class="code">${esc(c)}</div>
      </div>
    </div>`).join("");

    const html = `<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>Etiquetas Palete</title>
<style>
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;margin:18px}
  .page{page-break-after:always;break-after:page}
  .page:last-child{page-break-after:auto;break-after:auto}
  .box{border:1px solid #111;padding:14px;border-radius:14px;max-width:520px}
  h1{font-size:18px;margin:0 0 6px}
  .sub{color:#333;margin:0 0 10px}
  .code{font-family:ui-monospace,Menlo,Consolas,monospace;margin-top:8px}
  @media print { body{margin:0} .box{border:none} }
</style>
<script src="https://cdn.jsdelivr.net/npm/jsbarcode@3.11.6/dist/JsBarcode.all.min.js"><\/script>
</head>
<body>
  ${pages}
<script>
  (function(){
    const codes = ${JSON.stringify(list)};
    function go(){
      for(let i=0;i<codes.length;i++){
        try{
          JsBarcode("#b"+i, codes[i], {format:"CODE128", lineColor:"#111", width:2, height:80, displayValue:true, fontSize:14, margin:10});
        }catch(e){}
      }
      setTimeout(()=>{ try{ window.focus(); window.print(); }catch(e){} }, 150);
    }
    // Wait a moment for JsBarcode to load in the iframe
    setTimeout(go, 200);
  })();
<\/script>
</body>
</html>`;

    const doc = frame.contentWindow.document;
    doc.open();
    doc.write(html);
    doc.close();
  }




  function renderPallets(){
    const u = auth.currentUser;
    viewEl.innerHTML = `
      <div class="card">
        <h2 style="margin:0 0 8px">Gerador de códigos de barras (Pallets)</h2>
        <div class="hint">Gera um código único (CODE128) para colar/Imprimir e depois usar na operação (campo <b>Pallet</b>).</div>

        <div class="grid two" style="margin-top:10px">
          <div class="card soft">
            <div class="row">
              <div class="field">
                <label>Prefixo</label>
                <input id="pltPrefix" value="PLT" />
              </div>
              <div class="field">
                <label>Quantity a gerar</label>
                <input id="pltQty" type="number" min="1" step="1" value="1" />
              </div>
              <div class="right">
                <button class="btn ok" id="pltGen">Gerar</button>
              </div>
            </div>
            <div class="hint" style="margin-top:6px">Formato: <code>PREFIXO-AAAAMMDD-HHMMSS-XXXXX</code></div>
          </div>

          <div class="card soft">
            <div class="row">
              <div class="field">
                <label>Título etiqueta</label>
                <input id="pltTitle" value="PALETE" />
              </div>
              <div class="field">
                <label>Subtítulo (opcional)</label>
                <input id="pltSub" placeholder="Ex.: NEW / RETURNS" />
              </div>
            </div>
          </div>
        </div>

        <div id="pltMsg"></div>
        <div class="divider"></div>
        <h2 style="margin:0 0 8px">Reimprimir etiqueta de PALETE</h2>
        <div class="hint">Pica/insere o código de palete para voltar a imprimir. Se existir no stock, mostra também a localização e o produto.</div>
        <div class="row" style="margin-top:10px">
          <div class="field"><label>Código de Pallet</label><input id="pltReCode" placeholder="Pica o código..." /></div>
          <div class="right">
            <button class="btn ghost" id="pltReFind">Procurar</button>
            <button class="btn ok" id="pltRePrint" disabled>Imprimir</button>
          </div>
        </div>
        <div id="pltReInfo" style="margin-top:10px"></div>
        <div style="margin-top:10px;overflow:auto"><svg id="pltReSvg"></svg></div>
      </div>

      <div class="card" style="margin-top:12px">
        <h2 style="margin:0 0 8px">Códigos gerados</h2>
        <div class="row" style="align-items:center;gap:10px">
          <div class="hint">Toca/clica num código para copiar. Usa “Imprimir” para uma etiqueta, ou imprime tudo (1 por folha).</div>
          <div class="spacer"></div>
          <button class="btn ok" id="pltPrintAll" disabled>Imprimir tudo (1/folha)</button>
        </div>
        <div id="pltList" style="margin-top:10px;display:grid;gap:12px"></div>
      </div>
    `;

    setupPallets();
  }

  function setupPallets(){
    const prefix = $("pltPrefix");
    const qty = $("pltQty");
    const title = $("pltTitle");
    const sub = $("pltSub");
    const btn = $("pltGen");
    const msg = $("pltMsg");
    const list = $("pltList");
    const printAll = $("pltPrintAll");

    
    // Reimprimir
    const reCode = $("pltReCode");
    const reFind = $("pltReFind");
    const rePrint = $("pltRePrint");
    const reInfo = $("pltReInfo");
    const reSvg = $("pltReSvg");
    let reResolved = null;
let codes = [];

    function render(){
      list.innerHTML = codes.map((c, i)=>`
        <div class="card soft">
          <div class="row">
            <div class="pill mono" style="cursor:pointer" data-copy="${esc(c)}">${esc(c)}</div>
            <div class="spacer"></div>
            <button class="btn ghost" data-print="${i}">Imprimir</button>
          </div>
          <div style="margin-top:10px;overflow:auto">
            <svg id="pltSvg_${i}"></svg>
          </div>
        </div>
      `).join("") || `<div class="hint">Ainda não geraste códigos.</div>`;

      codes.forEach((c,i)=>{
        const svg = document.getElementById(`pltSvg_${i}`);
        renderBarcode(svg, c);
      });

      list.querySelectorAll("[data-copy]").forEach(el=>{
        el.onclick = async ()=>{
          const code = el.getAttribute("data-copy");
          try{
            await navigator.clipboard.writeText(code);
            msg.innerHTML = msgBox("✅ Copiado: " + esc(code), "ok");
          }catch(e){
            msg.innerHTML = msgBox("Copiar falhou (telemóvel às vezes bloqueia). Código: " + esc(code), "warn");
          }
        };
      });

      if(printAll){
        printAll.disabled = !(codes && codes.length);
        printAll.onclick = ()=>{
          if(!(codes && codes.length)) return;
          printPalletLabelsBatch({codes, title: title.value || "PALETE", subtitle: sub.value || ""});
        };
      }

      list.querySelectorAll("[data-print]").forEach(b=>{
        b.onclick = ()=>{
          const i = Number(b.getAttribute("data-print"));
          const code = codes[i];
          printPalletLabel({code, title: title.value || "PALETE", subtitle: sub.value || ""});
        };
      });
    }

    btn.onclick = ()=>{
      msg.innerHTML = "";
      const n = Math.max(1, Math.min(200, Math.floor(Number(qty.value||1))));
      const pref = prefix.value || "PLT";
      codes = Array.from({length:n}, ()=>generatePalletCode(pref));
      render();
    };

    render();
  

    async function doResolve(){
      if(!reCode || !reFind || !rePrint || !reInfo || !reSvg) return;
      const code = normalizeBarcode(reCode.value);
      if(!code){
        reInfo.innerHTML = msgBox("Pica o código de palete.", "warn");
        rePrint.disabled = true;
        reResolved = null;
        return;
      }
      renderBarcode(reSvg, code);

      try{
        const res = await resolvePalletGlobal(code);
        if(res.ok){
          reResolved = res;
          const s = res.stock || {};
          reInfo.innerHTML = msgBox(`Encontrado no stock • <b>${esc(res.position.code)}</b> • <b>${esc(res.product.name)}</b> • UND ${Number(s.qtyUnits||0)} • Pal ${Number(s.qtyPallets||0)}`, "ok");
          rePrint.disabled = false;
        }else if(res.reason==="multiplo"){
          reResolved = null;
          rePrint.disabled = false;
          reInfo.innerHTML = msgBox("Pallet existe em várias linhas/duplicada. Podes imprimir na mesma.", "warn");
        }else{
          reResolved = null;
          rePrint.disabled = false;
          reInfo.innerHTML = msgBox("Pallet não encontrada no stock (podes imprimir na mesma).", "warn");
        }
      }catch(e){
        reResolved = null;
        rePrint.disabled = false;
        reInfo.innerHTML = msgBox("Erro a procurar palete (podes imprimir na mesma).", "warn");
      }
    }

    if(reFind) reFind.onclick = doResolve;
    if(reCode) reCode.addEventListener("keydown", (e)=>{ if(e.key==="Enter"){ e.preventDefault(); doResolve(); }});
    if(rePrint) rePrint.onclick = ()=>{
      const code = normalizeBarcode(reCode.value);
      if(!code){ reInfo.innerHTML = msgBox("Pica o código de palete.", "warn"); return; }
      let subtitle = "";
      if(reResolved && reResolved.position && reResolved.product){
        subtitle = `${reResolved.position.code} • ${reResolved.product.name}`;
      }
      printPalletLabel({code, title: title.value || "PALETE", subtitle: subtitle || (sub.value || "")});
    };
}

// ===== Auth UI =====
  $("btnLogin").onclick = async ()=>{
    const box = $("authMsg");
    if(box) box.innerHTML = "";
    try{
      const email = $("loginEmail").value.trim();
      const pass  = $("loginPass").value;
      if(!email || !pass) throw new Error("Preenche email e password.");
      await signInWithEmailAndPassword(auth, email, pass);
      if(box) box.innerHTML = msgBox("✅ Login efetuado.", "ok");
    }catch(err){
      const code = err.code ? `<div class="hint">Código: <code>${esc(err.code)}</code></div>` : "";
      const msg = err.message || String(err);
      let tips = "";
      const c = (err.code || "").toString();
      if(c.includes("auth/unauthorized-domain")){
        tips = `<div class="hint">Domínio não autorizado. Publica em Firebase Hosting ou adiciona o domínio em Authentication → Settings → Authorized domains.</div>`;
      }
      if(box) box.innerHTML = msgBox(`❌ Erro de login: ${esc(msg)}${code}${tips}`, "err");
      console.error(err);
    }
  };
  $("btnLogout").onclick = async ()=>{ try{ await signOut(auth); }catch(e){} };
  $("btnReload").onclick = ()=>location.reload();

  // placeholder inicial
  viewEl.innerHTML = `<div class="card"><div class="hint">A verificar sessão...</div></div>`;

  onAuthStateChanged(auth, (user)=>{
    state.user = user || null;

    // No session -> show only login screen
    if(!state.user){
      setGate("login");
      return;
    }

    // Role check (do NOT auto-logout; show diagnostic)
    if(!canOperate(state.user)){
      const em = emailOfUser(state.user);
      const am = $("authMsg");
      if(am){
        am.innerHTML = msgBox(
          "No access for this email: <span class='mono'>"+esc(em || "(no email)")+
          "</span><br>Expected: <span class='mono'>@admin.com</span> or <span class='mono'>@wh.com</span>.",
          "err"
        );
      }
      // keep login screen visible so user can switch account
      setGate("login");
      return;
    }

    // Try to render. Only hide login after render OK.
    try{
      const am=$("authMsg"); if(am) am.innerHTML = msgBox("Opening…", "warn");
      render();
      setGate("app");
    }catch(e){
      console.error(e);
      const am=$("authMsg");
      if(am) am.innerHTML = msgBox("Error opening app: "+esc(e.message||e), "err");
      setGate("login");
    }
  });

  
  // expose helpers for safety (module scope)
  window.transferReplenish = transferReplenish;
/***********************
   REGRAS FIRESTORE (colar no Firebase Console → Firestore Rules)

   rules_version = '2';
   service cloud.firestore {
     match /databases/{database}/documents {

       function signedIn() { return request.auth != null; }
       function email() { return signedIn() ? request.auth.token.email : ""; }
       function isAdmin() { return signedIn() && email().matches('.*@admin\\.com$'); }
       function isWh()    { return signedIn() && email().matches('.*@wh\\.com$'); }
       function canOperate() { return isAdmin() || isWh(); }

       match /products/{id} {
         allow read: if canOperate();
         allow write: if isAdmin();
       }
       match /positions/{id} {
         allow read: if canOperate();
         allow write: if isAdmin();
       }
       match /stockItems/{id} {
         allow read, write: if canOperate();
       }
       match /movements/{id} {
         allow create: if canOperate();
         allow read: if canOperate();
         // permitir marcação de anulado/edição (a app faz o ajuste de stock)
         allow update: if canOperate();
         allow delete: if false;
       }
     }
   }

   ***********************/</script>
</body>
</html>
